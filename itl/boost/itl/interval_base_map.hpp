/*----------------------------------------------------------------------------+
Copyright (c) 2007-2008: Joachim Faulhaber
+-----------------------------------------------------------------------------+
Copyright (c) 1999-2006: Cortex Software GmbH, Kantstrasse 57, Berlin
+-----------------------------------------------------------------------------+
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
+----------------------------------------------------------------------------*/

/* ------------------------------------------------------------------
class interval_base_map
--------------------------------------------------------------------*/
#ifndef __interval_base_map_h_JOFA_990223__
#define __interval_base_map_h_JOFA_990223__

#include <limits>
#include <itl/notate.hpp>
#include <itl/itl_map.hpp>
#include <itl/interval_base_set.hpp>
#include <itl/interval_sets.hpp>
//CL devirt #include <itl/maps.hpp>
#include <itl/itl_interval.hpp>


#define const_FOR_IMPLMAP(iter) for(typename ImplMapT::const_iterator iter=_map.begin(); (iter)!=_map.end(); (iter)++)
#define FOR_IMPLMAP(iter) for(typename ImplMapT::iterator iter=_map.begin(); (iter)!=_map.end(); (iter)++)

namespace itl
{

/// Implements a map as a map of intervals (abstract base class)
/**    
    Abstract template-class <b>interval_base_map</b>
    implements a map as a map of intervals

    Template parameter <b>DomainT</b>: Domain type of the map. Also type of the
    map's keys.
    
    Suitable as domain types are all datatypes that posess a partial order.
    In particular all discrete atomic datatypes like <tt>int, short, long</tt> and
    atomic pseudo-continuous datatypes <tt>float, double</tt> may be instantiated.
      
       Template parameter <b>CodomainT</b>: The map's codomain type or data type: Type
    of associated values contained in the map.

    Datatypes for the codomain parameter have to <b>implement</b> operations
    <tt>+=</tt>, <tt>-=</tt>, <tt>==</tt> (equality) and <tt>CodomainT()</tt> (default constructor).

    The default constructor <tt>CodomainT()</tt> has to contruct a neutral element
    such that the following holds:

      If <tt>x = y; y += CodomainT();</tt> then <tt>x==y;</tt> and
      If <tt>x = y; y -= CodomainT();</tt> then <tt>x==y;</tt>
  
    Template parameter <b>Interval=itl::interval</b>: Type of interval template used
    to implement the set. The default <b>itl::interval</b> uses the
    interval class that comes with this library. Own implementation of interval
    classes are possible (but not trivial).
  
    <b>interval_base_map</b> implements a map <tt>map<DomainT, CodomainT></tt> as a map
    of intervals <tt>map<interval<DomainT>, CodomainT, exclusive_less<interval_type> ></tt>

    Interval maps <tt>interval_base_map<DomainT,CodomainT></tt> can be used similar (and in many
    aspects exactly like) common stl-maps. Unlike to stl-maps where you store
    a value for every key an interval map stores a contents value for an interval of
    keys. In it's degenerated form the key intervals contain a single element
    only. Then the interval map works like a normal stl-map. But if you work in problem
    domains where you associate values to large contiguous intervals, interval maps
    are very useful and efficient.

    <b>Class <tt>interval_base_map</tt>  yields the following benefits: </b>
  
    <ul>
        <li> A set of intervals is conceived as the domain set of the map. 
            The complexity involved with
            operations on intervals maps is encapsulated. The user of the class who
            wants to perform operations on interval maps is no more concerned
            with questions of overlapping, joining and bordering intervals.
        <li>
            <b>interval_base_map</b> gives an efficient implementation of maps consisting
            of larger contiguous chunks. Very large, even uncountably infinite maps
            can be represented in a compact way and handled efficiently.
    </ul>

    <b>Restrictions: </b>
    
    A small number of functions can only be used for <b>discrete</b> domain datatypes 
    (<tt>short, int, Date</tt> etc.) that implement operators <tt>++</tt> and <tt>--</tt>.

    These functions are tagged in the documentation. Using such functions
    for continuous domain datatypes yields compiletime errors. C.f. getting
    the <tt>first()</tt> element of a left open interval makes sense for intervals of
    int but not for intervals of double.

    @author  Joachim Faulhaber
*/
template
<
    class SubType,
    typename DomainT,
    typename CodomainT,
    class Traits = itl::neutron_absorber,
    template<class>class Interval = itl::interval,
    template<class>class Compare  = std::less,
    template<class>class Alloc    = std::allocator
>
#ifdef USE_CONCEPTS
//conceptgcc is still too buggy
//requires 
//{
//    std::LessThanComparable<DomainT>,
//  std::EqualityComparable<Codomain>
//}
#endif
class interval_base_map
{
public:

/** @name A: Type definitions for the template class 
*/
//@{ 
    typedef Traits traits;
    typedef SubType sub_type;
    typedef interval_base_map<SubType,DomainT,CodomainT,
                              itl::neutron_absorber,Interval,Compare,Alloc>
                              neutron_absorber_type;

    /// Domain type (type of the keys) of the map
    typedef DomainT   domain_type;
    /// Domain type (type of the keys) of the map
    typedef CodomainT codomain_type;
    /// basic value type
    typedef std::pair<domain_type,codomain_type> base_value_type;
    /// The interval type of the map
    typedef Interval<DomainT> interval_type;

    /// Comparison functor for domain values
    typedef Compare<DomainT> domain_compare;
    /// Comparison functor for intervals which are keys as well
    typedef exclusive_less<interval_type> interval_compare;

    /// Comparison functor for keys
    typedef exclusive_less<interval_type> key_compare;

    /// The allocator type of the set
    typedef Alloc<std::pair<const interval_type, codomain_type> > 
        allocator_type;

    /// Container type for the implementation 
    typedef itl::map<interval_type,codomain_type,Traits,
                     exclusive_less,Alloc> ImplMapT;

    /// key type of the implementing container
    typedef typename ImplMapT::key_type   key_type;
    /// value type of the implementing container
    typedef typename ImplMapT::value_type value_type;
    /// data type of the implementing container
    typedef typename ImplMapT::value_type::second_type data_type;

    /// iterator for iteration over intervals
    typedef typename ImplMapT::iterator iterator;
    /// const_iterator for iteration over intervals
    typedef typename ImplMapT::const_iterator const_iterator;

    // Corresponding abstract interval set type
    //typedef interval_base_set<SetSubType,DomainT,Interval,Compare,Alloc> interval_base_set_type;

    /// The atomized type is elementbased map that is equivalent to the interval map
    typedef typename itl::map<DomainT,CodomainT,
                              Traits,Compare,Alloc> atomized_type;
//@}

public:
    inline static bool has_symmetric_difference() 
    { return is_set<codomain_type>::value || !traits::absorbs_neutrons || traits::emits_neutrons; }

public:
/** @name B: Constructors, destructors, assignment 
*/
//@{ 
    /// Default constructor for the empty map 
    interval_base_map(){}
    /// Copy constructor
    interval_base_map(const interval_base_map& src): _map(src._map) {}

    /// Assignment operator
    interval_base_map& operator = (const interval_base_map& src) 
    {
        _map.ImplMapT::operator=(src._map);
        return *this;  
    }
//@}

/** @name C: Basic container functions
*/
//@{ 
    /// clear the map
    void clear() { _map.clear(); }

    /// is the map empty?
    bool empty()const { return _map.empty(); }

    /// Does the map contain the key element \c x
    bool contains(const DomainT& x)const
    { 
        typename ImplMapT::const_iterator it = _map.find(interval_type(x)); 
        return it != _map.end(); 
    }

    /// Does the map contain the element pair <tt>x = (key_element,value)</tt>?
    bool contains(const base_value_type& x)const
    {
        typename ImplMapT::const_iterator it = _map.find(interval_type(x.KEY_VALUE));
        return (it!=_map.end() && (*it).CONT_VALUE==x.CONT_VALUE);  //CodomainT::OP == 
    }

    /// swap the content of containers
    void swap(interval_base_map& x) { _map.swap(x._map); }
//@}


    DomainT lower()const { return (*(_map.begin())).KEY_VALUE.lower(); }
    DomainT upper()const { return (*(_map.rbegin())).KEY_VALUE.upper(); }
    // DomainT first()const { return (*(_map.begin())).KEY_VALUE.first(); } // JODO NONCONT
    // DomainT last()const { return (*(_map.rbegin())).KEY_VALUE.last(); }// JODO NONCONT
    interval_type first_interval()const { return (*(_map.begin())).KEY_VALUE; }
    interval_type last_interval()const { return (*(_map.rbegin())).KEY_VALUE; }

    
    // Functions that are common with interval_base_set --------------------------------

/** @name E: Bounds and other selectors
    */
//@{ 
    // JODO: bounds of the map like interval_base_set
    /// Number of intervals which is also the size of the iteration over the map
    size_t interval_count()const { return _map.size(); }
    /// Size of the iteration over this container
    size_t iterative_size()const { return _map.size(); }

    /// enclosing Interval
    interval_type enclosure()const { return first_interval().span(last_interval()); }

    /// Gives the domain of the map as interval set
	template 
	<
		template
		<	
			class DomainT, template<class>class Interval, 
			template<class>class Compare, template<class>class Alloc
		>
		class IntervalSet
	>
    void domain(IntervalSet<DomainT,Interval,Compare,Alloc>& dom)const 
    { 
		dom.clear(); 
		const_FOR_IMPLMAP(it) 
			dom += (*it).KEY_VALUE; 
	} 
//@}
    


/** @name F: Tester
*/
//@{
    /// <tt>*this</tt> is subset of <tt>super</tt>
    bool contained_in(const interval_base_map& super)const;

    /// Equality
    bool equal(const interval_base_map& x2)const
    { return contained_in(x2) && x2.contained_in(*this); }

    ///  <tt>*this</tt> and <tt>x2</tt> are disjoint; their intersection is empty.
    //JODO bool disjoint_to(const interval_base_map& x2)const
    //wrong: { return ( empty() || x2.empty() || last_interval().exclusive_less(x2.first_interval()) ); }
//@}

//-----------------------------------------------------------------------------
/** @name G.add: Addition */
//@{

    /// Addition of a base value pair using a Combinator operation.
    /** Addition of a base value pair <tt>x := pair(k,y)</tt> where 
        <tt>base_value_type:=pair<DomainT,CodomainT></tt>
    
        This adds (inserts) a value <tt>y</tt> for a single key <tt>k</tt> into the map.
        If <tt>k</tt> already has a value <tt>y0</tt> associated with it, <tt>y0</tt>
        will be 'incremented' by <tt>y</tt> calling <tt>Combinator(y0,y)</tt>.

        If Combinator implements addition (+=) associated values will contain sums.
        If Combinator implements max, associated values will contain maximal values and so on.
    */
    template<template<class>class Combinator>
    void add(const base_value_type& x) 
    { that()->add<Combinator>( value_type(interval_type(x.KEY_VALUE), x.CONT_VALUE) ); }

    /// Addition of a value pair using a Combinator operation.
    /** Addition of a value pair <tt>x := pair(I,y)</tt> where <tt>base_value_type:=pair<DomainT,CodomainT></tt>
    
        This adds (inserts) a value <tt>y</tt> an interval <tt>I</tt> into the map.

        If no values are associated already within the range of <tt>I</tt>,
        <tt>y</tt> will be associated to that interval.

        If there are associated values, in the range of <tt>I</tt>, then all
        those values within the ranges of their intervals,
        are combined by <tt>y</tt>. This is done via the <tt>Combinator</tt> function
        that is passed as template parameter.

        If Combinator implements addition (+=) associated values will contain sums.
        If Combinator implements max, associated values will contain maximal values and so on.
    */
    template<template<class>class Combinator>
    void add(const value_type& x) { that()->add<Combinator>(x); };

    /// Addition of a base value pair.
    /** Addition of a base value pair <tt>x := pair(k,y)</tt> where <tt>base_value_type:=pair<DomainT,CodomainT></tt>
    
        This adds (inserts) a value <tt>y</tt> for a single key <tt>k</tt> into the map.
        If <tt>k</tt> already has a value <tt>y0</tt> associated with it, <tt>y0</tt>
        will be incremented by <tt>y</tt> using operator <tt>+=</tt>.
        
        Addition and subtraction are reversible as follows:
        <tt>m0=m; m.add(x); m.subtract(x);</tt> implies <tt>m==m0 </tt>         
    */
    void add(const base_value_type& x) 
    { add( value_type(interval_type(x.KEY_VALUE), x.CONT_VALUE) ); }

    /// Addition of a base value pair.
    /** Addition of an value pair <tt>x=(I,y)</tt>

        This adds (inserts) a value <tt>y</tt> for an interval <tt>I</tt> into the map.

        If no values are associated already within the range of <tt>I</tt>,
        <tt>y</tt> will be associated to that interval.

        If there are associated values, in the range of <tt>I</tt>, then all
        those values within the ranges of their intervals,
        are incremented by <tt>y</tt>. This is done via operator <tt>+=</tt>
        which has to be implemented for CodomainT. 

        Insertion and subtraction are reversible as follows:
        <tt>m0=m; m.add(x); m.subtract(x);</tt> implies <tt>m==m0 </tt>         
    */
    void add(const value_type& x) { that()->add<inplace_plus>(x); }

    /// Addition of a base value pair.
    /** Addition of an value pair <tt>x=(I,y)</tt>

        This adds (inserts) a value <tt>y</tt> for an interval <tt>I</tt> into the map,
        identical member function add. 

        If no values are associated already within the range of <tt>I</tt>,
        <tt>y</tt> will be associated to that interval.

        If there are associated values, in the range of <tt>I</tt>, then all
        those values within the ranges of their intervals,
        are incremented by <tt>y</tt>. This is done via operator <tt>+=</tt>
        which has to be implemented for CodomainT. 

        Insertion and subtraction are reversible as follows:
        <tt>m0=m; m += x; m -= x;</tt> implies <tt>m==m0 </tt>         
    */
    interval_base_map& operator += (const value_type& x) 
    { that()->add(x); return *this; }
//@}


//-----------------------------------------------------------------------------
/** @name G.sub: Subtraction */
//@{

    /// Subtraction of an base value pair using a Combinator operation
    /** Subtraction of an base value pair <tt>x=(k,y)</tt> 

        This subtracts a value <tt>y</tt> for a key <tt>k</tt> from the map.

        If there is an associated values \c y0, in for <tt>k</tt>, 
        \c y0 is combined with \c y by <tt>Combinator(y0,y)</tt>.

        A Combinator for subtract is usually an inverse function of
        the corresponding add<Combinator>. 
    */
    template<template<class>class Combinator>
    void subtract(const base_value_type& x)
    { that()->subtract<Combinator>( value_type(interval_type(x.KEY_VALUE), x.CONT_VALUE) ); }


    /// Subtraction of an interval value pair using a Combinator operation
    /** Subtraction of an interval value pair  <tt>x=(I,y)</tt> 

        This subtracts a value <tt>y</tt> for an interval <tt>I</tt> from the map.

        If there are associated values, in the range of <tt>I</tt>, all
        those values within the ranges of their intervals,
        are decremented by <tt>y</tt>. This is done via the Combinator function
        that is passed a template parameter.
    */
    template<template<class>class Combinator>
    void subtract(const value_type& x){ that()->subtract<Combinator>(x); }


    /// Subtraction of a base value pair.
    /** Subtraction of a base value pair <tt>x=(k,y)</tt> where <tt>base_value_type:=pair<DomainT,CodomainT></tt>

        This subtracts a value <tt>y</tt> for a single key <tt>k</tt> from the map.
        If <tt>k</tt> already has a value <tt>y0</tt> associated with it, <tt>y0</tt>
        will be decremented by <tt>y</tt>: <tt>y0 -= y</tt> via operator <tt>-=</tt>
        which has to be implemented for CodomainT. If <tt>y</tt> becomes
        the neutral element CodomainT() <tt>k</tt> will also be removed from
        the map, if the Traits include the property neutron_absorber. 

        Insertion and subtraction are reversible as follows:
        <tt>m0=m; m.add(x); m.subtract(x);</tt> implies <tt>m==m0 </tt>         
    */
    void subtract(const base_value_type& x)
    { that()->subtract( value_type(interval_type(x.KEY_VALUE), x.CONT_VALUE) ); }


    /// Subtraction of an interval value pair
    /** Subtraction of an interval value pair  <tt>x=(I,y)</tt> 

        This subtracts a value <tt>y</tt> for an interval <tt>I</tt> from the map.

        If there are associated values, in the range of <tt>I</tt>, all
        those values within the ranges of their intervals,
        are decremented by <tt>y</tt>. This is done usign operator -=.

        If <tt>y</tt> becomes the neutral element CodomainT() <tt>k</tt> will
        also be removed from the map, if the Traits include the property 
        neutron_absorber. 
    */
    void subtract(const value_type& x)
    {
        if(Traits::emits_neutrons)
            that()->add<inplace_minus>(x); 
        else 
            that()->subtract<inplace_minus>(x); 
    }

    /// Subtraction of an interval value pair
    /** Subtraction of an interval value pair  <tt>x=(I,y)</tt>.
        This subtracts a value <tt>y</tt> for an interval <tt>I</tt> from the map.

        If there are associated values, in the range of <tt>I</tt>, all
        those values within the ranges of their intervals,
        are decremented by <tt>y</tt>. This is done usign operator -=.

        If <tt>y</tt> becomes the neutral element CodomainT() <tt>k</tt> will
        also be removed from the map, if the Traits include the property 
        neutron_absorber. 
    */
    void operator -= (const value_type& x) { subtract(x); }

//@}


//-----------------------------------------------------------------------------
/** @name G.ins&ers: Insertion and Erasure */
//@{

    /// Insertion of a base value pair.
    /** Insertion of a base value pair <tt>x=(k,y)</tt> where <tt>base_value_type:=pair<DomainT,CodomainT></tt>
    
        This inserts a value <tt>y</tt> for a single key <tt>k</tt> into the map.
        Insertion is done only if there is no value \c y0 in the map for key \c k.

        This is the insertion semantics known from std::map::insert.
    */
    void insert(const base_value_type& x) 
    { insert( value_type(interval_type(x.KEY_VALUE), x.CONT_VALUE) ); }

    /// Insertion of an interval value pair
    /** Insertion of an interval value pair <tt>x=(I,y)</tt>

        This inserts a value <tt>y</tt> for an interval <tt>I</tt> into the map.
        Insertion is done for all sections of interval \c I that are not yet
        associated with a value.

        This is the insertion semantics known from std::map::insert.

        \c insert(x) is equivalent to \c add<inplace_identity>(x)
    */
    void insert(const value_type& x){ that()->insert(x); }

    /// Erase a base value pair from the map
    /** Erase a base value pair <tt>x=(k,y)</tt>.
        This does erase a base value pair <tt>x=(k,y)</tt> form the map, if
        a value \c y is stored for key \c k.
    */
    void erase(const base_value_type& x) 
    { erase( value_type(interval_type(x.KEY_VALUE), x.CONT_VALUE) ); }

    /// Erase a interval value pair from the map
    /** Erase a interval value pair <tt>x=(I,y)</tt>.
        This does erase a interval value pair <tt>x=(I,y)</tt> form the map.

        At all places in the range of interval \c I, where a value of \c y
        is stored, it will be erased.

        \c erase(x) is equivalent to \c subtract<inplace_erasure>(x)
    */
    void erase(const value_type& x){ that()->erase(x); }


    /// Erase an associated value for a key
    /** Erase an associated value <tt>y</tt> for the key <tt>k</tt> from the map.

        Any value \c y that is stored for key \c k will be erased.
    */
    void erase(const DomainT& x) { erase(interval_type(x)); }

    /// Erase all associated values for an interval
    /** Erase all associated values within the range of the interval <tt>x</tt>
        from the map.
    */
    void erase(const interval_type& x);

    /// Erase all associated values for a set of intervals
    /** Erase an entire interval set <tt>x</tt> from the map.

        All values within the scope of the interval set \c x will be erased.
    */
    template<class SetSubType>
    void erase(const interval_base_set<SetSubType,DomainT,Interval,Compare,Alloc>& x)
    {
        typedef interval_base_set<SetSubType,DomainT,Interval,Compare,Alloc> interval_base_set_type;
        for(typename interval_base_set_type::const_iterator x_ = x.begin(); x_ != x.end(); ++x_)
            erase(*x_);
    }

    /// Erase an interval map from this interval map
    /** Erase an entire interval map <tt>x</tt> from the map.

        All values within the scope of the interval map \c x will be erased,
        If there are equal values associated in \c *this map.
    */
    void erase(const interval_base_map& x);

//@}

//-----------------------------------------------------------------------------
/** @name G.sect: Intersection */
//@{

    /// Intersection with an interval
    /** Compute the intersection of <tt>*this</tt> and the interval <tt>x</tt>; assign
        result to the interval map <tt>section</tt>.

        The result of the intersection with an interval has to be a interval map,
        because a whole set of intervals may exist in <tt>*this</tt> within the range
        of the interval <tt>x</tt>.
        
        Use the intersect function to find intervals or elements in an interval map.

        Given
        
        <tt>split_interval_map<int> x, sec; interval<int> i; fill x; fill i</tt>

        <tt>x.intersect(sec,i);</tt> 

        if <tt>i</tt> can be found completely in <tt>x</tt> then

        <tt>sec.size()==1</tt> and <tt>(*sec.begin()).first==i</tt>

        No find function is implemented, because all find operations can be expressed
        as intersections.
    */
    void intersect(interval_base_map& section, const interval_type& x)const;

    /// Intersect with an interval and assign
    interval_base_map& operator *= (const interval_type& x)
    { 
        interval_base_map section; 
        intersect(section, x); 
        swap(section); 
        return *this; 
    }

    /// Intersection with an interval value pair
    /** Compute an intersection with the value pair \c x=(I,y). The intersection
        operation is progagated to the associated values: For common intervals
        the intersection of associated values is stored in the resulting map
        \c section.
    */
    void map_intersect(interval_base_map& section, const value_type& x)const;

    /// Intersect with an interval value pair and assign
    interval_base_map& operator *= (const value_type& x)
    { 
        if(Traits::emits_neutrons)
            return (*this) += x;
        else if(Traits::absorbs_neutrons && !is_set<CodomainT>::value)
            return (*this) += x;
        else
        {
            interval_base_map section; 
            map_intersect(section, x); 
            swap(section); 
            return *this; 
        }
    }

    /// Intersection with an interval set
    /** Compute the intersection of <tt>*this</tt> and the interval set <tt>x</tt>;
        assign result to the interval map <tt>section</tt>.    */
    template<class SetSubType>
    void intersect(interval_base_map& section, const interval_base_set<SetSubType,DomainT,Interval,Compare,Alloc>& sectant)const
    {
        section.clear();
        if(sectant.empty()) return;

        interval_base_map aux;
        // THINK JODO optimize using the ordering: if intervalls are beyond borders we can terminate

        typename interval_base_set<SetSubType,DomainT,Interval,Compare,Alloc>::const_iterator it = sectant.begin();
        while(it != sectant.end())
        {
            aux.clear();
            intersect(aux, *it++);
            section += aux;
        }
    }

    /// Intersect with an interval set and assign
    /** Compute the intersection of <tt>*this</tt> and the interval set <tt>x</tt>;
        assign result to <tt>*this</tt> interval map

        Call of <tt>x *= y</tt> stands for <tt>x = x intersection with y </tt>
    */
    template<class SetSubType>
    interval_base_map& operator *= (const interval_base_set<SetSubType,DomainT,Interval,Compare,Alloc>& x)
    {
        interval_base_map section;
        intersect(section, x);
        swap(section); 
        return *this;
    }

    /// Intersection with an interval map
    /** Compute the intersection of <tt>*this</tt> and the interval map <tt>x</tt>;
        assign result to the interval map <tt>section</tt>.    */
    template<class SubMapType>
    void map_intersect(interval_base_map& section, 
                       const interval_base_map<SubMapType,DomainT,CodomainT,
                                               Traits,Interval,Compare,Alloc>& x)const;


    /*  Compute the intersection of <tt>*this</tt> and the interval map <tt>x</tt>;
        assign result to <tt>*this</tt> interval map

        Call of <tt>x *= y</tt> stands for <tt>x = x intersection with y </tt>
    */
    //CL interval_base_map& operator *= (const interval_base_map& x);
//@}


//-----------------------------------------------------------------------------
/** @name H.mor: Morphic modifiers */
//@{

    /// Removal of neutral element values
    /** All value pairs \c (I,y) that have neutral elements \c y==codomain_type()
        as associated values are removed form the map.
    */
    void absorb_neutrons()
    {
        //content_is_neutron<key_type, data_type> neutron_dropper;
        if(!Traits::absorbs_neutrons)
            drop_if(content_is_neutron<value_type>());
    }

    /// Copies this map into a neutron_absorber type.
    /** \c x is a copy of \c *this as a neutron_aborber.
        A neutron absorber is a map that does not store neutral elements
        (<tt>neutron() == codomain_type()</tt>)
        as associated values.
    */
    void as_neutron_absorber(neutron_absorber_type& x)const
    { FOR_IMPLMAP(it) x.add(*it); }

    /// Join bounding intervals    
    interval_base_map& join();
    
    /// Join bounding intervals    and merge equivalent elements by +=
    void merge();
    
    interval_base_map& scale_up(DomainT factor, DomainT max)
    { FORALL(typename ImplMapT, it, _map) (const_cast<interval_type&>((*it).KEY_VALUE)).scale_up(factor, max); return *this; }
    
    
//@}
 


/** @name I: Interval search
    */
//@{
    /** A find function has <b>NOT</b> been implemented; Use \ref intersect
        as a generalized find operation on interval maps.
    
        All find operations can be expressed by means of intersection \ref intersect
        or \ref operator *=. Searching for an interval in an interval map yields
        an interval map anyway in the general case.
    */
//@}


/** @name J: Interval iterators
    */
//@{
    ///
    iterator begin() { return _map.begin(); }
    ///
    iterator end()   { return _map.end(); }
    ///
    const_iterator begin()const { return _map.begin(); }
    ///
    const_iterator end()const   { return _map.end(); }
//@}



/** @name K: Selection by predicates
    */
//@{
    /// Keep all elements where property <tt>p</tt> holds, remove otherwise
    interval_base_map& keep_if(const itl::property<value_type>& p){ _map.keep_if(p); return *this; }

    /// Remove all elements where property <tt>p</tt> holds, keep all others
    interval_base_map& drop_if(const itl::property<value_type>& p){ _map.drop_if(p); return *this; }

    /// Copy all elements if property <tt>p</tt> holds
    interval_base_map& copy_if( const itl::property<value_type>& p, const interval_base_map& src)
    { _map.copy_if(p, src._map); return *this; }

//@}


/** @name S: String representation
    */
//@{
    /** Convert the interval map to string (c.f. \ref value)

        This string converter is based on a general converter function <tt>as_string</tt>
        and the template class \ref value which serves as base for string
        representation.
    */
    std::string as_string() const;
//@}
    
/** @name T: For discrete domain datatypes only that implement operators <tt>++</tt> 
        and <tt>--</tt>
    */
//@{

    /** Smallest element of the map (wrt. the partial ordering on DomainT).
        first() does not exist for continuous datatypes and open interval bounds.
    */
    DomainT first()const { return (*(_map.begin())).KEY_VALUE.first(); }  // JODO NONCONT

    /** Largest element of the map (wrt. the partial ordering on DomainT).
        first() does not exist for continuous datatypes and open interval bounds.
    */
    DomainT last()const { return (*(_map.rbegin())).KEY_VALUE.last(); } // JODO NONCONT


    // JODO TEST
    /** Number of elements in the set (cardinality). 
        Infinite for continuous domain datatyps
        <b>Nicht getestet</b>
    */
    DomainT size()const;


    /** Sum of associated elements of the map
        <b>Nicht getestet</b> */
    CodomainT sum()const;

    /**    Set interval bounds to the type <tt>bt</tt> for intervals in the map.

        Interval bounds of different types are created by opeations on
        interval maps. This function allows to reset them uniformly without,
        of course, changing their value. This is only possible for discrete
        domain datatypes.
    */
    void uniformBounds( typename interval<DomainT>::bound_types bt);

    void closeLeftBounds();
//@}

    void recJoin();


    template<typename IteratorT>
    static const key_type& key_value(IteratorT& value_){ return (*value_).first; }

    template<typename IteratorT>
    static const data_type& data_value(IteratorT& value_){ return (*value_).second; }

    template<typename IteratorT>
    static codomain_type codomain_value(IteratorT& value_){ return (*value_).second; }

    template<typename LeftIterT, typename RightIterT>
    static bool key_less(LeftIterT& lhs_, RightIterT& rhs_) { return key_compare()((*lhs_).first, (*rhs_).first); }

    static value_type make_domain_element(const domain_type& dom_val, const codomain_type& codom_val)
    { return value_type(interval_type(dom_val), codom_val); }

protected:
    sub_type* that() { return static_cast<sub_type*>(this); }
    const sub_type* that()const { return static_cast<const sub_type*>(this); }

protected:
    ImplMapT _map;
} ;



template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
bool interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::contained_in(const interval_base_map& super)const
{
    // x2 should be larger than *this; so every element in this should be in x2
    const_FOR_IMPLMAP(it) 
        if(!super.that()->contains(*it)) 
            return false;
    return true;
}


template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
void interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>
    ::intersect(interval_base_map& section, const interval_type& x)const
{
    section.clear();
    if(x.empty()) return;

    typename ImplMapT::const_iterator fst_it = _map.lower_bound(x);
    typename ImplMapT::const_iterator end_it = _map.upper_bound(x);

    for(typename ImplMapT::const_iterator it=fst_it; it != end_it; it++) 
    {
        interval_type isec; 
        (*it).KEY_VALUE.intersect(isec, x);

        if(!isec.empty())
            section.add( value_type(isec, (*it).CONT_VALUE) );
    }
}


template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
void interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>
    ::map_intersect(interval_base_map& section, 
                    const typename interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>
                    ::value_type& sectant)const
{
    section.clear();
    interval_type sectant_interval = sectant.KEY_VALUE;
    if(sectant_interval.empty()) return;

    typename ImplMapT::const_iterator fst_it = _map.lower_bound(sectant_interval);
    typename ImplMapT::const_iterator end_it = _map.upper_bound(sectant_interval);

    for(typename ImplMapT::const_iterator it=fst_it; it != end_it; it++) 
    {
        interval_type common_interval; 
        (*it).KEY_VALUE.intersect(common_interval, sectant_interval);

        if(!common_interval.empty())
        {
            //CodomainT inner_section = (*it).CONT_VALUE;
            //inner_section *= sectant.CONT_VALUE;
            //section.that()->add( value_type(common_interval, inner_section) );
            section.that()->add( value_type(common_interval, (*it).CONT_VALUE) );
            if(is_set<CodomainT>::value)
                section.that()->add<inplace_star>( value_type(common_interval, sectant.CONT_VALUE) );
            else
                section.that()->add<inplace_plus>( value_type(common_interval, sectant.CONT_VALUE) );
        }
    }
}


//JODO Section algorithms for map and set arguments are virually the same
template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
    template<class SubType2>
void interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::
    map_intersect(interval_base_map& interSection, 
                  const interval_base_map<SubType2,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& sectant)const
{
    interSection.clear();
    if(sectant.empty()) return;

    interval_base_map aux;
    // THINK JODO optimize using the ordering: if intervalls are beyond borders we can terminate

    typename interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::const_iterator 
        it = sectant.begin();
    while(it != sectant.end())
    {
        aux.clear();
        map_intersect(aux, *it++);
        interSection += aux;
    }
}



template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>
    ::join()
{
    iterator it=_map.begin();
    if(it==_map.end()) 
        return *this;

    iterator nxt=it; nxt++;
    if(nxt==_map.end()) 
        return *this;

    while(nxt != _map.end())
    {
        if(    (*it).KEY_VALUE.touches((*nxt).KEY_VALUE)
            && (*it).CONT_VALUE == (*nxt).CONT_VALUE      ) //CodomainT::OP ==
        {
            iterator fst_mem = it;  // hold the fist member
            
            // go noodling on while touchin members found
            it++; nxt++;
            while(     nxt != _map.end()
                    && (*it).KEY_VALUE.touches((*nxt).KEY_VALUE)
                    && (*it).CONT_VALUE == (*nxt).CONT_VALUE     ) //CodomainT::OP ==
            { it++; nxt++; }

            // finally we arrive at the end of a sequence of joinable intervals
            // and it points to the last member of that sequence
            iterator lst_mem = it, end_mem = nxt;
            interval_type joinedInterval((*fst_mem).KEY_VALUE);
            joinedInterval.extend((*lst_mem).KEY_VALUE);
            CodomainT value = (*fst_mem).CONT_VALUE; //CodomainT::OP =
            
            _map.erase(fst_mem, end_mem);
            it = _map.insert(value_type(joinedInterval, value)).ITERATOR;

            it++; // go on for the next after the currently inserted
            nxt=it; if(nxt!=_map.end())nxt++;
        }
        else { it++; nxt++; }
    }
    return *this;
}

template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
void interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::merge()
{
    iterator it=_map.begin();
    if(it==_map.end()) return;
    iterator nxt=it; nxt++;
    if(nxt==_map.end()) return;

    while(nxt != _map.end())
    {
        if(    (*it).KEY_VALUE.touches((*nxt).KEY_VALUE)
            && (*it).CONT_VALUE == (*nxt).CONT_VALUE      ) //CodomainT::OP ==
        {
            iterator fst_mem = it;  // hold the fist member
            
            CodomainT mergedValue = (*it).CONT_VALUE; //CodomainT::OP =
            mergedValue += (*nxt).CONT_VALUE;

            // go noodling on while touchin members found
            it++; nxt++;
            while(     nxt != _map.end()
                    && (*it).KEY_VALUE.touches((*nxt).KEY_VALUE)
                    && (*it).CONT_VALUE == (*nxt).CONT_VALUE     ) //CodomainT::OP ==
            { 
                mergedValue += (*nxt).CONT_VALUE;
                it++; nxt++; 
            }

            // finally we arrive at the end of a sequence of joinable intervals
            // and it points to the last member of that sequence
            iterator lst_mem = it, end_mem = nxt;
            interval_type joinedInterval((*fst_mem).KEY_VALUE);
            joinedInterval.extend((*lst_mem).KEY_VALUE);
            
            _map.erase(fst_mem, end_mem);
            it = _map.insert(value_type(joinedInterval, mergedValue)).ITERATOR;

            it++; // go on for the next after the currently inserted
            nxt=it; if(nxt!=_map.end())nxt++;
        }
        else { it++; nxt++; }
    }
}


template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
std::string interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::as_string()const
{
    std::string res(""); 
    const_FOR_IMPLMAP(it) {
        std::string cur("("); 
        cur += (*it).KEY_VALUE.as_string();
        cur += ",";
        cur += itl::to_string<CodomainT>::apply((*it).CONT_VALUE);
        cur += ")";
        res += cur;
    }
    return res; 
}

template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
DomainT interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::size()const
{
    DomainT size = DomainT();
    const_FOR_IMPLMAP(it) size += (*it).KEY_VALUE.size();
    return size;
}


template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
CodomainT interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::sum()const
{
    CodomainT sum = CodomainT();
    const_FOR_IMPLMAP(it) 
        sum += (*it).CONT_VALUE;
    return sum;
}


template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
void interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::uniformBounds( typename interval<DomainT>::bound_types bt)
{
    // I can do this only, because I am shure that the contents and the
    // ordering < on interval is invariant wrt. this transformation on bounds
    FOR_IMPLMAP(it) const_cast<interval_type&>((*it).KEY_VALUE).transformBounds(bt);
}

template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
void interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::closeLeftBounds()
{
    // I can do this only, because I am shure that the contents and the
    // ordering < on interval is invariant wrt. this transformation on bounds
    FOR_IMPLMAP(it) const_cast<interval_type&>((*it).KEY_VALUE).closeLeftBound();
}



template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
void interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>
    ::erase(const interval_type& x_itv)
{
    if(x_itv.empty()) return;
    iterator fst_it = _map.lower_bound(x_itv);
    if(fst_it==_map.end()) return;
    iterator end_it = _map.upper_bound(x_itv);
    
    typename ImplMapT::iterator it=fst_it, nxt_it=fst_it, victim;
    interval_type leftResid;   // left residual from first overlapping interval of *this
    (*it).KEY_VALUE.left_surplus(leftResid,x_itv);
    interval_type rightResid;  // right residual from last overlapping interval of *this
    
    CodomainT leftResid_ContVal = (*it).CONT_VALUE;
    CodomainT rightResid_ContVal;
    
    while(it!=end_it)
    { 
        if((++nxt_it)==end_it) 
        {
            (*it).KEY_VALUE.right_surplus(rightResid,x_itv);
            rightResid_ContVal = (*it).CONT_VALUE;
        }
        victim = it; it++; _map.erase(victim);
    }
    
    add(value_type(leftResid,  leftResid_ContVal));
    add(value_type(rightResid, rightResid_ContVal));
}


template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
void interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::erase(const interval_base_map& erasure)
{
    const_FORALL(typename interval_base_map, value_pair_, erasure)
        that()->erase(*value_pair_);
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// itl::global function templates
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
    
//-----------------------------------------------------------------------------
// equality
//-----------------------------------------------------------------------------
template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
inline bool operator == (const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& lhs,
                         const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& rhs)
{
    //MEMO PORT: This implemetation worked with stlport, sgi and gnu 
    // implementations of the stl. But using MSVC-implementation
    // results in runtime error! So I had to provide an independent
    // safe implemetation.
    //return std::equal(lhs.begin(), lhs.end(), rhs.begin());
    return Set::lexicographical_equal(lhs, rhs);
}

template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
inline bool is_protonic_equal(const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& lhs,
                              const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& rhs)
{
    interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc> lhs0 = lhs;
    interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc> rhs0 = rhs;

    lhs0.absorb_neutrons();
    rhs0.absorb_neutrons();

    return Set::lexicographical_equal(lhs0, rhs0);
}

template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
inline bool is_element_equal(const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& lhs,
                             const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& rhs)
{
    interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc> lhs_joined = lhs;
    interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc> rhs_joined = rhs;

    lhs_joined.join();
    rhs_joined.join();

    return Set::lexicographical_equal(lhs_joined, rhs_joined);
}


//-----------------------------------------------------------------------------
// order
//-----------------------------------------------------------------------------
template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
inline bool operator < (const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& lhs,
                        const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& rhs)
{
    return std::lexicographical_compare(
        lhs.begin(), lhs.end(), rhs.begin(), rhs.end(), 
        Compare<std::pair<Interval<DomainT>, CodomainT> >()
        );
}

template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
inline bool operator <= (const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& lhs,
                        const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& rhs)
{
    return lhs < rhs || lhs == rhs;
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// op= op_assign inplace_ops
//-----------------------------------------------------------------------------
// insertion, erasure
//-----------------------------------------------------------------------------
template 
<
    class SubType,
    class DomainT, class CodomainT, 
    class Traits, template<class>class Interval, 
    template<class>class Compare, template<class>class Alloc
>
interval_base_map<SubType,DomainT,CodomainT,
                  Traits,Interval,Compare,Alloc>& 
insert
(
          interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& object,
    const interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& insertee
)
{
    typedef interval_base_map<SubType,DomainT,CodomainT,Traits,
                              Interval,Compare,Alloc>    map_type;
    const_FORALL(typename map_type, elem_, insertee) 
        object.insert(*elem_); 

    return object; 
}


template 
<
    class SubType,
    class DomainT, class CodomainT, 
    class Traits, template<class>class Interval, 
    template<class>class Compare, template<class>class Alloc
>
interval_base_map<SubType,DomainT,CodomainT,
                  Traits,Interval,Compare,Alloc>& 
erase
(
          interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& object,
    const interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& erasee
)
{
    typedef interval_base_map<SubType,DomainT,CodomainT,Traits,
                              Interval,Compare,Alloc>    map_type;
    const_FORALL(typename map_type, elem_, erasee) 
        object.erase(*elem_); 

    return object; 
}

//-----------------------------------------------------------------------------
// addition (set union) += and subtraction (set difference) -=
//-----------------------------------------------------------------------------

template 
<
    class SubType,
    class DomainT, class CodomainT, 
    class Traits, template<class>class Interval, 
    template<class>class Compare, template<class>class Alloc
>
interval_base_map<SubType,DomainT,CodomainT,
                  Traits,Interval,Compare,Alloc>& 
operator +=
(
          interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& object,
    const interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& operand
)
{
    typedef interval_base_map<SubType,DomainT,CodomainT,Traits,
                              Interval,Compare,Alloc>    map_type;
    const_FORALL(typename map_type, elem_, operand) 
        object.add(*elem_); 

    return object; 
}

template 
<
    class SubType,
    class DomainT, class CodomainT, 
    class Traits, template<class>class Interval, 
    template<class>class Compare, template<class>class Alloc
>
interval_base_map<SubType,DomainT,CodomainT,
                  Traits,Interval,Compare,Alloc>& 
operator -=
(
          interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& object,
    const interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& operand
)
{
    typedef interval_base_map<SubType,DomainT,CodomainT,Traits,
                              Interval,Compare,Alloc>    map_type;
    const_FORALL(typename map_type, elem_, operand) 
        object.subtract(*elem_); 

    return object; 
}


//-----------------------------------------------------------------------------
// erasure via keysets: map -= key_set
//-----------------------------------------------------------------------------
template 
<
    class SubType, class SetSubType,
    class DomainT, class CodomainT, 
    class Traits, template<class>class Interval, 
    template<class>class Compare, template<class>class Alloc
>
interval_base_map<SubType,DomainT,CodomainT,
                  Traits,Interval,Compare,Alloc>& 
operator -=
(
          interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& object,
    const interval_base_set<SetSubType,DomainT,
                            Interval,Compare,Alloc>& erasure
)
{
    object.template erase<SetSubType>(erasure);
    return object; 
}



//-----------------------------------------------------------------------------
// intersection *=
//-----------------------------------------------------------------------------
template 
<
    class SubType,
    class DomainT, class CodomainT, 
    class Traits, template<class>class Interval, 
    template<class>class Compare, template<class>class Alloc
>
interval_base_map<SubType,DomainT,CodomainT,
                  Traits,Interval,Compare,Alloc>& 
operator *=
(
          interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& object,
    const interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& operand
)
{

    typedef interval_base_map
            <SubType,DomainT,CodomainT,
             Traits,Interval,Compare,Alloc> map_type;

    if(Traits::emits_neutrons)
        return object += operand;
    else if(Traits::absorbs_neutrons && !is_set<CodomainT>::value)
        return object += operand;
    else
    {
        map_type section;
        object.map_intersect(section, operand);
        object.swap(section);
        return object;
    }
}


//-----------------------------------------------------------------------------
// min, max
//-----------------------------------------------------------------------------
template 
<
    class SubType,
    class DomainT, class CodomainT, 
    class Traits, template<class>class Interval, 
    template<class>class Compare, template<class>class Alloc
>
interval_base_map<SubType,DomainT,CodomainT,
                  Traits,Interval,Compare,Alloc>& 
min_assign
(
          interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& object,
    const interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& operand
)
{
    typedef interval_base_map<SubType,DomainT,CodomainT,Traits,
                              Interval,Compare,Alloc>    map_type;
    const_FORALL(typename map_type, elem_, operand) 
        object.template add<inplace_min >(*elem_); 

    return object; 
}

template 
<
    class SubType,
    class DomainT, class CodomainT, 
    class Traits, template<class>class Interval, 
    template<class>class Compare, template<class>class Alloc
>
interval_base_map<SubType,DomainT,CodomainT,
                  Traits,Interval,Compare,Alloc>& 
max_assign
(
          interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& object,
    const interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& operand
)
{
    typedef interval_base_map<SubType,DomainT,CodomainT,Traits,
                              Interval,Compare,Alloc>    map_type;
    const_FORALL(typename map_type, elem_, operand) 
        object.template add<inplace_max>(*elem_); 

    return object; 
}

//---------------------------------------------------------------------------------


} // namespace itl

#endif


