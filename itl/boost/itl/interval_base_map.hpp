/*----------------------------------------------------------------------------+
Copyright (c) 2007-2008: Joachim Faulhaber
+-----------------------------------------------------------------------------+
Copyright (c) 1999-2006: Cortex Software GmbH, Kantstrasse 57, Berlin
+-----------------------------------------------------------------------------+
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
+----------------------------------------------------------------------------*/

/* ------------------------------------------------------------------
class interval_base_map
--------------------------------------------------------------------*/
#ifndef __interval_base_map_h_JOFA_990223__
#define __interval_base_map_h_JOFA_990223__

#include <limits>
#include <boost/itl/notate.hpp>
#include <boost/itl/map.hpp>
#include <boost/itl/interval_base_set.hpp>
#include <boost/itl/interval_sets.hpp>
#include <boost/itl/interval.hpp>


#define const_FOR_IMPLMAP(iter) for(typename ImplMapT::const_iterator iter=_map.begin(); (iter)!=_map.end(); (iter)++)
#define FOR_IMPLMAP(iter) for(typename ImplMapT::iterator iter=_map.begin(); (iter)!=_map.end(); (iter)++)

namespace boost{namespace itl
{

template<class DomainT, class CodomainT>
struct base_pair
{
    DomainT   key;
    CodomainT data;

    base_pair(const DomainT& key_value, const CodomainT& data_value)
        :key(key_value), data(data_value){}

    base_pair(const std::pair<DomainT,CodomainT>& std_pair)
        :key(std_pair.first), data(std_pair.second){}
};



/// Implements a map as a map of intervals (abstract base class)
/**    
    Abstract template-class <b>interval_base_map</b>
    implements a map as a map of intervals

    Template parameter <b>DomainT</b>: Domain type of the map. Also type of the
    map's keys.
    
    Suitable as domain types are all datatypes that posess a partial order.
    In particular all discrete atomic datatypes like <tt>int, short, long</tt> and
    atomic pseudo-continuous datatypes <tt>float, double</tt> may be instantiated.
      
       Template parameter <b>CodomainT</b>: The map's codomain type or data type: Type
    of associated values contained in the map.

    Datatypes for the codomain parameter have to <b>implement</b> operations
    <tt>+=</tt>, <tt>-=</tt>, <tt>==</tt> (equality) and <tt>CodomainT()</tt> (default constructor).

    The default constructor <tt>CodomainT()</tt> has to contruct a neutral element
    such that the following holds:

      If <tt>x = y; y += CodomainT();</tt> then <tt>x==y;</tt> and
      If <tt>x = y; y -= CodomainT();</tt> then <tt>x==y;</tt>
  
    Template parameter <b>Interval=itl::interval</b>: Type of interval template used
    to implement the set. The default <b>itl::interval</b> uses the
    interval class that comes with this library. Own implementation of interval
    classes are possible (but not trivial).
  
    <b>interval_base_map</b> implements a map <tt>map<DomainT, CodomainT></tt> as a map
    of intervals <tt>map<interval<DomainT>, CodomainT, exclusive_less<interval_type> ></tt>

    Interval maps <tt>interval_base_map<DomainT,CodomainT></tt> can be used similar (and in many
    aspects exactly like) common stl-maps. Unlike to stl-maps where you store
    a value for every key an interval map stores a contents value for an interval of
    keys. In it's degenerated form the key intervals contain a single element
    only. Then the interval map works like a normal stl-map. But if you work in problem
    domains where you associate values to large contiguous intervals, interval maps
    are very useful and efficient.

    <b>Class <tt>interval_base_map</tt>  yields the following benefits: </b>
  
    <ul>
        <li> A set of intervals is conceived as the domain set of the map. 
            The complexity involved with
            operations on intervals maps is encapsulated. The user of the class who
            wants to perform operations on interval maps is no more concerned
            with questions of overlapping, joining and bordering intervals.
        <li>
            <b>interval_base_map</b> gives an efficient implementation of maps consisting
            of larger contiguous chunks. Very large, even uncountably infinite maps
            can be represented in a compact way and handled efficiently.
    </ul>

    <b>Restrictions: </b>
    
    A small number of functions can only be used for <b>discrete</b> domain datatypes 
    (<tt>short, int, Date</tt> etc.) that implement operators <tt>++</tt> and <tt>--</tt>.

    These functions are tagged in the documentation. Using such functions
    for continuous domain datatypes yields compiletime errors. C.f. getting
    the <tt>first()</tt> element of a left open interval makes sense for intervals of
    int but not for intervals of double.

    @author  Joachim Faulhaber
*/
template
<
    class SubType,
    typename DomainT,
    typename CodomainT,
    class Traits = itl::neutron_absorber,
    template<class>class Interval = itl::interval,
    template<class>class Compare  = std::less,
    template<class>class Alloc    = std::allocator
>
#ifdef USE_CONCEPTS
//conceptgcc is still too buggy
//requires 
//{
//    std::LessThanComparable<DomainT>,
//  std::EqualityComparable<Codomain>
//}
#endif
class interval_base_map
{
public:

/** @name A: Type definitions for the template class 
*/
//@{ 
    typedef Traits traits;
    typedef SubType sub_type;

    typedef interval_base_map<SubType,DomainT,CodomainT,
                              Traits,Interval,Compare,Alloc>
                              type;

    typedef interval_base_map<SubType,DomainT,CodomainT,
                              itl::neutron_absorber,Interval,Compare,Alloc>
                              neutron_absorber_type;

    /// Domain type (type of the keys) of the map
    typedef DomainT   domain_type;
    /// Domain type (type of the keys) of the map
    typedef CodomainT codomain_type;
    /// basic value type
    typedef std::pair<domain_type,codomain_type> base_value_type;
    /// Auxiliary type to help the compiler resolve ambiguities when using std::make_pair
    typedef base_pair<domain_type,codomain_type> base_pair_type;
    /// The interval type of the map
    typedef Interval<DomainT> interval_type;

    /// The difference type of an interval which is sometimes different form the domain_type
    typedef typename interval_type::difference_type difference_type;

    /// The size type of an interval which is mostly std::size_t
    typedef typename interval_type::size_type size_type;

    /// Comparison functor for domain values
    typedef Compare<DomainT> domain_compare;
    /// Comparison functor for intervals which are keys as well
    typedef exclusive_less<interval_type> interval_compare;

    /// Comparison functor for keys
    typedef exclusive_less<interval_type> key_compare;

    /// The allocator type of the set
    typedef Alloc<std::pair<const interval_type, codomain_type> > 
        allocator_type;

    /// Container type for the implementation 
    typedef itl::map<interval_type,codomain_type,Traits,
                     exclusive_less,Alloc> ImplMapT;

    /// key type of the implementing container
    typedef typename ImplMapT::key_type   key_type;
    /// value type of the implementing container
    typedef typename ImplMapT::value_type value_type;
    /// data type of the implementing container
    typedef typename ImplMapT::value_type::second_type data_type;

    /// iterator for iteration over intervals
    typedef typename ImplMapT::iterator iterator;
    /// const_iterator for iteration over intervals
    typedef typename ImplMapT::const_iterator const_iterator;
    /// iterator for reverse iteration over intervals
    typedef typename ImplMapT::reverse_iterator reverse_iterator;
    /// const_iterator for iteration over intervals
    typedef typename ImplMapT::const_reverse_iterator const_reverse_iterator;


    // Corresponding abstract interval set type
    //typedef interval_base_set<SetSubType,DomainT,Interval,Compare,Alloc> interval_base_set_type;

    /// The atomized type is elementbased map that is equivalent to the interval map
    typedef typename itl::map<DomainT,CodomainT,
                              Traits,Compare,Alloc> atomized_type;
//@}

public:
    inline static bool has_symmetric_difference() 
    { return is_set<codomain_type>::value || !traits::absorbs_neutrons || traits::emits_neutrons; }

public:
/** @name B: Constructors, destructors, assignment 
*/
//@{ 
    /// Default constructor for the empty map 
    interval_base_map(){}

    /// Copy constructor
    interval_base_map(const interval_base_map& src): _map(src._map) {}

    /// Assignment operator
    interval_base_map& operator = (const interval_base_map& src) 
    { 
        if(this==&src) 
            return *this;

        that()->assign(src);
        return *this; 
    }

    /// swap the content of containers
    void swap(interval_base_map& x) { _map.swap(x._map); }
//@}

/** @name C: Basic container functions
*/
//@{ 
    /// clear the map
    void clear() { _map.clear(); }

    /// is the map empty?
    bool empty()const { return _map.empty(); }

    /// Does the map contain the key element \c x
    bool contains(const DomainT& x)const
    { 
        typename ImplMapT::const_iterator it = _map.find(interval_type(x)); 
        return it != _map.end(); 
    }

    /// Does the map contain the element pair <tt>x = (key_element,value)</tt>?
    bool contains(const base_pair_type& x)const
    { return that()->contains_(value_type(interval_type(x.key), x.data));    }

    bool contains(const value_type& x)const
    { return that()->contains_(x); }

    /** Does <tt>*this</tt> container contain <tt>sub</tt>? */
    bool contains(const interval_base_map& sub)const 
    { return sub.contained_in(*this); }

//@}


    DomainT lower()const { return (*(_map.begin())).KEY_VALUE.lower(); }
    DomainT upper()const { return (*(_map.rbegin())).KEY_VALUE.upper(); }

    iterator lower_bound(const key_type& interval)
    { return _map.lower_bound(interval); }

    iterator upper_bound(const key_type& interval)
    { return _map.upper_bound(interval); }

    const_iterator lower_bound(const key_type& interval)const
    { return _map.lower_bound(interval); }

    const_iterator upper_bound(const key_type& interval)const
    { return _map.upper_bound(interval); }


    // Functions that are common with interval_base_set --------------------------------

/** @name E: Bounds and other selectors
    */
//@{ 
    // JODO: bounds of the map like interval_base_set
    /// Number of intervals which is also the size of the iteration over the map
    size_t interval_count()const { return _map.size(); }
    /// Size of the iteration over this container
    size_t iterative_size()const { return _map.size(); }

    /// Gives the domain of the map as interval set
    template 
    <
        template
        <    
            class DomT, template<class>class Interv, 
            template<class>class Comp, template<class>class Allc
        >
        class IntervalSet
    >
    void domain(IntervalSet<DomainT,Interval,Compare,Alloc>& dom)const 
    { 
        dom.clear(); 
        const_FOR_IMPLMAP(it) 
            dom += (*it).KEY_VALUE; 
    } 
//@}
    


/** @name F: Tester
*/
//@{
    /// <tt>*this</tt> is subset of <tt>super</tt>
    bool contained_in(const interval_base_map& super)const;

    /// Equality
    //CL bool equal(const interval_base_map& x2)const
    //{ return contained_in(x2) && x2.contained_in(*this); }

    ///  <tt>*this</tt> and <tt>x2</tt> are disjoint; their intersection is empty.
    //JODO bool is_disjoint(const interval_base_map& x2)const
    //wrong: { return ( empty() || x2.empty() || last_interval().exclusive_less(x2.first_interval()) ); }
//@}

//-----------------------------------------------------------------------------
/** @name G.add: Addition */
//@{

    /// Addition of a base value pair using a Combinator operation.
    /** Addition of a base value pair <tt>x := pair(k,y)</tt> where 
        <tt>base_value_type:=pair<DomainT,CodomainT></tt>
    
        This adds (inserts) a value <tt>y</tt> for a single key <tt>k</tt> into the map.
        If <tt>k</tt> already has a value <tt>y0</tt> associated with it, <tt>y0</tt>
        will be 'incremented' by <tt>y</tt> calling <tt>Combinator(y0,y)</tt>.

        If Combinator implements addition (+=) associated values will contain sums.
        If Combinator implements max, associated values will contain maximal values and so on.
    */
    template<template<class>class Combinator>
    SubType& add(const base_pair_type& x) 
    { 
        that()->template add_<Combinator>( value_type(interval_type(x.KEY_VALUE), x.CONT_VALUE) ); 
        return *that();
    }

    /// Addition of a value pair using a Combinator operation.
    /** Addition of a value pair <tt>x := pair(I,y)</tt> where <tt>base_value_type:=pair<DomainT,CodomainT></tt>
    
        This adds (inserts) a value <tt>y</tt> an interval <tt>I</tt> into the map.

        If no values are associated already within the range of <tt>I</tt>,
        <tt>y</tt> will be associated to that interval.

        If there are associated values, in the range of <tt>I</tt>, then all
        those values within the ranges of their intervals,
        are combined by <tt>y</tt>. This is done via the <tt>Combinator</tt> function
        that is passed as template parameter.

        If Combinator implements addition (+=) associated values will contain sums.
        If Combinator implements max, associated values will contain maximal values and so on.
    */
    template<template<class>class Combinator>
    SubType& add(const value_type& x) 
    { that()->template add_<Combinator>(x); return *that(); };

    /// Addition of a base value pair.
    /** Addition of a base value pair <tt>x := pair(k,y)</tt> where <tt>base_value_type:=pair<DomainT,CodomainT></tt>
    
        This adds (inserts) a value <tt>y</tt> for a single key <tt>k</tt> into the map.
        If <tt>k</tt> already has a value <tt>y0</tt> associated with it, <tt>y0</tt>
        will be incremented by <tt>y</tt> using operator <tt>+=</tt>.
        
        Addition and subtraction are reversible as follows:
        <tt>m0=m; m.add(x); m.subtract(x);</tt> implies <tt>m==m0 </tt>         
    */
    SubType& add(const base_pair_type& x) 
    { return add( value_type(interval_type(x.key), x.data) ); }

    /// Addition of a base value pair.
    /** Addition of an value pair <tt>x=(I,y)</tt>

        This adds (inserts) a value <tt>y</tt> for an interval <tt>I</tt> into the map.

        If no values are associated already within the range of <tt>I</tt>,
        <tt>y</tt> will be associated to that interval.

        If there are associated values, in the range of <tt>I</tt>, then all
        those values within the ranges of their intervals,
        are incremented by <tt>y</tt>. This is done via operator <tt>+=</tt>
        which has to be implemented for CodomainT. 

        Insertion and subtraction are reversible as follows:
        <tt>m0=m; m.add(x); m.subtract(x);</tt> implies <tt>m==m0 </tt>         
    */
    SubType& add(const value_type& x) 
    { that()->template add_<inplace_plus>(x); return *that(); }

    /// Addition of a base value pair.
    /** Addition of an value pair <tt>x=(I,y)</tt>

        This adds (inserts) a value <tt>y</tt> for an interval <tt>I</tt> into the map,
        identical member function add. 

        If no values are associated already within the range of <tt>I</tt>,
        <tt>y</tt> will be associated to that interval.

        If there are associated values, in the range of <tt>I</tt>, then all
        those values within the ranges of their intervals,
        are incremented by <tt>y</tt>. This is done via operator <tt>+=</tt>
        which has to be implemented for CodomainT. 

        Insertion and subtraction are reversible as follows:
        <tt>m0=m; m += x; m -= x;</tt> implies <tt>m==m0 </tt>         
    */
    //CL refa
    //interval_base_map& operator += (const value_type& x) 
    //{ that()->add_(x); return *this; }

//@}


//-----------------------------------------------------------------------------
/** @name G.sub: Subtraction */
//@{

    /// Subtraction of an base value pair using a Combinator operation
    /** Subtraction of an base value pair <tt>x=(k,y)</tt> 

        This subtracts a value <tt>y</tt> for a key <tt>k</tt> from the map.

        If there is an associated values \c y0, in for <tt>k</tt>, 
        \c y0 is combined with \c y by <tt>Combinator(y0,y)</tt>.

        A Combinator for subtract is usually an inverse function of
        the corresponding add<Combinator>. 
    */
    template<template<class>class Combinator>
    void subtract(const base_pair_type& x)
    { that()->template subtract_<Combinator>( value_type(interval_type(x.KEY_VALUE), x.CONT_VALUE) ); }

    /// Subtraction of an interval value pair using a Combinator operation
    /** Subtraction of an interval value pair  <tt>x=(I,y)</tt> 

        This subtracts a value <tt>y</tt> for an interval <tt>I</tt> from the map.

        If there are associated values, in the range of <tt>I</tt>, all
        those values within the ranges of their intervals,
        are decremented by <tt>y</tt>. This is done via the Combinator function
        that is passed a template parameter.
    */
    template<template<class>class Combinator>
    void subtract(const value_type& x){ that()->template subtract_<Combinator>(x); }


    /// Subtraction of a base value pair.
    /** Subtraction of a base value pair <tt>x=(k,y)</tt> where <tt>base_value_type:=pair<DomainT,CodomainT></tt>

        This subtracts a value <tt>y</tt> for a single key <tt>k</tt> from the map.
        If <tt>k</tt> already has a value <tt>y0</tt> associated with it, <tt>y0</tt>
        will be decremented by <tt>y</tt>: <tt>y0 -= y</tt> via operator <tt>-=</tt>
        which has to be implemented for CodomainT. If <tt>y</tt> becomes
        the neutral element CodomainT() <tt>k</tt> will also be removed from
        the map, if the Traits include the property neutron_absorber. 

        Insertion and subtraction are reversible as follows:
        <tt>m0=m; m.add(x); m.subtract(x);</tt> implies <tt>m==m0 </tt>         
    */
    SubType& subtract(const base_pair_type& x)
    { 
        that()->subtract_( value_type(interval_type(x.key), x.data) ); 
        return *that();
    }


    /// Subtraction of an interval value pair
    /** Subtraction of an interval value pair  <tt>x=(I,y)</tt> 

        This subtracts a value <tt>y</tt> for an interval <tt>I</tt> from the map.

        If there are associated values, in the range of <tt>I</tt>, all
        those values within the ranges of their intervals,
        are decremented by <tt>y</tt>. This is done usign operator -=.

        If <tt>y</tt> becomes the neutral element CodomainT() <tt>k</tt> will
        also be removed from the map, if the Traits include the property 
        neutron_absorber. 
    */
    SubType& subtract(const value_type& x)
    {
        if(Traits::emits_neutrons)
            that()->template add_<inplace_minus>(x); 
        else 
            that()->template subtract_<inplace_minus>(x); 
    
        return *that();
    }

    /// Subtraction of an interval value pair
    /** Subtraction of an interval value pair  <tt>x=(I,y)</tt>.
        This subtracts a value <tt>y</tt> for an interval <tt>I</tt> from the map.

        If there are associated values, in the range of <tt>I</tt>, all
        those values within the ranges of their intervals,
        are decremented by <tt>y</tt>. This is done usign operator -=.

        If <tt>y</tt> becomes the neutral element CodomainT() <tt>k</tt> will
        also be removed from the map, if the Traits include the property 
        neutron_absorber. 
    */
    //CL refa
    //SubType& operator -= (const value_type& x) 
    //{ that()->subtract_(x); return *that(); }

//@}


//-----------------------------------------------------------------------------
/** @name G.ins&ers: Insertion and Erasure */
//@{

    /// Insertion of a base value pair.
    /** Insertion of a base value pair <tt>x=(k,y)</tt> where <tt>base_value_type:=pair<DomainT,CodomainT></tt>
    
        This inserts a value <tt>y</tt> for a single key <tt>k</tt> into the map.
        Insertion is done only if there is no value \c y0 in the map for key \c k.

        This is the insertion semantics known from std::map::insert.
    */
    SubType& insert(const base_pair_type& x) 
    { 
        that()->insert_( value_type(interval_type(x.key), x.data) ); 
        return *that();
    }

    /// Insertion of an interval value pair
    /** Insertion of an interval value pair <tt>x=(I,y)</tt>

        This inserts a value <tt>y</tt> for an interval <tt>I</tt> into the map.
        Insertion is done for all sections of interval \c I that are not yet
        associated with a value.

        This is the insertion semantics known from std::map::insert.

        \c insert(x) is equivalent to \c add<inplace_identity>(x)
    */
    SubType& insert(const value_type& x)
    { that()->insert_(x); return *that(); }

    /// Erase a base value pair from the map
    /** Erase a base value pair <tt>x=(k,y)</tt>.
        This does erase a base value pair <tt>x=(k,y)</tt> form the map, if
        a value \c y is stored for key \c k.
    */
    SubType& erase(const base_pair_type& x) 
    { 
        that()->erase_(value_type(interval_type(x.key), x.data));
        return *that();
    }

    /// Erase a interval value pair from the map
    /** Erase a interval value pair <tt>x=(I,y)</tt>.
        This does erase a interval value pair <tt>x=(I,y)</tt> form the map.

        At all places in the range of interval \c I, where a value of \c y
        is stored, it will be erased.

        \c erase(x) is equivalent to \c subtract<inplace_erasure>(x)
    */
    SubType& erase(const value_type& x)
    { that()->erase_(x); return *that(); }


    /// Erase an associated value for a key
    /** Erase an associated value <tt>y</tt> for the key <tt>k</tt> from the map.

        Any value \c y that is stored for key \c k will be erased.
    */
    SubType& erase(const DomainT& x) 
    { erase(interval_type(x)); return *that(); }

    /// Erase all associated values for an interval
    /** Erase all associated values within the range of the interval <tt>x</tt>
        from the map.
    */
    SubType& erase(const interval_type& x);

    /// Erase all associated values for a set of intervals
    /** Erase an entire interval set <tt>x</tt> from the map.

        All values within the scope of the interval set \c x will be erased.
    */
    template<class SetSubType>
    SubType& erase(const interval_base_set<SetSubType,DomainT,Interval,Compare,Alloc>& x)
    {
        typedef interval_base_set<SetSubType,DomainT,Interval,Compare,Alloc> interval_base_set_type;
        for(typename interval_base_set_type::const_iterator x_ = x.begin(); x_ != x.end(); ++x_)
            erase(*x_);
    
        return *that();
    }

    /// Erase an interval map from this interval map
    /** Erase an entire interval map <tt>x</tt> from the map.

        All values within the scope of the interval map \c x will be erased,
        If there are equal values associated in \c *this map.
    */
    SubType& erase(const interval_base_map& x);

//@}

//-----------------------------------------------------------------------------
/** @name G.sect: Intersection */
//@{

    /// Intersection with an interval
    /** Compute the intersection of <tt>*this</tt> and the interval <tt>x</tt>; assign
        result to the interval map <tt>section</tt>.

        The result of the intersection with an interval has to be a interval map,
        because a whole set of intervals may exist in <tt>*this</tt> within the range
        of the interval <tt>x</tt>.
        
        Use the intersect function to find intervals or elements in an interval map.

        Given
        
        <tt>split_interval_map<int> x, sec; interval<int> i; fill x; fill i</tt>

        <tt>x.intersect(sec,i);</tt> 

        if <tt>i</tt> can be found completely in <tt>x</tt> then

        <tt>sec.size()==1</tt> and <tt>(*sec.begin()).first==i</tt>

        No find function is implemented, because all find operations can be expressed
        as intersections.
    */
    //CL void intersect(interval_base_map& section, const interval_type& x)const;

    template<class SectantT>
    void intersect(interval_base_map& section, const SectantT& sectant)const
    {
        section.clear();
        add_intersection(section, sectant);
    }

    void add_intersection(interval_base_map& section, const domain_type& x)const
    { add_intersection(section, interval_type(x)); }

    void add_intersection(interval_base_map& section, const base_pair_type& x)const
    { add_intersection(section, value_type(interval_type(x.key), x.data)); }

    /// Intersection with an interval value pair
    /** Compute an intersection with the value pair \c x=(I,y). The intersection
        operation is progagated to the associated values: For common intervals
        the intersection of associated values is stored in the resulting map
        \c section.
    */
    void add_intersection(interval_base_map& section, const value_type& x)const;

    void add_intersection(interval_base_map& section, const interval_type& x)const;

    template
    <
        template
        <    
            class DomT, template<class>class Interv, 
            template<class>class Comp, template<class>class Allc
        >
        class IntervalSet
    >
    void add_intersection
    (
              interval_base_map& section, 
        const IntervalSet<DomainT,Interval,Compare,Alloc>& sectant
    )const
    {
        typedef IntervalSet<DomainT,Interval,Compare,Alloc> set_type;
        if(sectant.empty()) return;

        // THINK JODO optimize using the ordering: if intervalls are beyond borders we can terminate
        typename set_type::const_iterator it = sectant.begin();
        while(it != sectant.end())
            add_intersection(section, *it++);
    }


    /// Intersection with an interval map
    /** Compute the intersection of <tt>*this</tt> and the interval map <tt>x</tt>;
        assign result to the interval map <tt>section</tt>.    */
    template
    <
        template
        <    
            class DomT, class CodomT, 
            class Trts, template<class>class Interv, 
            template<class>class Comp, template<class>class Allc
        >
        class IntervalMap
    >
    void add_intersection
    (
        interval_base_map& intersection,
        const IntervalMap<DomainT,CodomainT,Traits,Interval,Compare,Alloc>& sectant
    )const;

//@}

//-----------------------------------------------------------------------------
/** @name H.mor: Morphic modifiers */
//@{

    /// Removal of neutral element values
    /** All value pairs \c (I,y) that have neutral elements \c y==codomain_type()
        as associated values are removed form the map.
    */
    void absorb_neutrons()
    {
        //content_is_neutron<key_type, data_type> neutron_dropper;
        if(!Traits::absorbs_neutrons)
			erase_if(content_is_neutron<value_type>());
    }

    /// Copies this map into a neutron_absorber type.
    /** \c x is a copy of \c *this as a neutron_aborber.
        A neutron absorber is a map that does not store neutral elements
        (<tt>neutron() == codomain_type()</tt>)
        as associated values.
    */
    void as_neutron_absorber(neutron_absorber_type& x)const
    { FOR_IMPLMAP(it) x.add(*it); }

    /// Join bounding intervals    
    interval_base_map& join();
            
//@}
 


/** @name I: Interval search
    */
//@{
    /** A find function has <b>NOT</b> been implemented; Use \ref intersect
        as a generalized find operation on interval maps.
    
        All find operations can be expressed by means of intersection \ref intersect
        or \ref operator *=. Searching for an interval in an interval map yields
        an interval map anyway in the general case.
    */
//@}


/** @name J: Interval iterators
    */
//@{
    ///
    iterator begin() { return _map.begin(); }
    ///
    iterator end()   { return _map.end(); }
    ///
    const_iterator begin()const { return _map.begin(); }
    ///
    const_iterator end()const   { return _map.end(); }
    ///
    reverse_iterator rbegin() { return _map.rbegin(); }
    ///
    reverse_iterator rend()   { return _map.rend(); }
    ///
    const_reverse_iterator rbegin()const { return _map.rbegin(); }
    ///
    const_reverse_iterator rend()const   { return _map.rend(); }
//@}



/** @name K: Selection by predicates
    */
//@{
    /// Remove all elements where property <tt>p</tt> holds, keep all others
    interval_base_map& erase_if(const itl::property<value_type>& p){ _map.erase_if(p); return *this; }

    /// Copy all elements if property <tt>p</tt> holds
    interval_base_map& copy_if( const itl::property<value_type>& p, const interval_base_map& src)
    { _map.copy_if(p, src._map); return *this; }

//@}


/** @name S: String representation
    */
//@{
    /** Convert the interval map to string (c.f. \ref value)

        This string converter is based on a general converter function <tt>as_string</tt>
        and the template class \ref value which serves as base for string
        representation.
    */
    std::string as_string() const;
//@}
    
/** @name T: For discrete domain datatypes only that implement operators <tt>++</tt> 
        and <tt>--</tt>
    */
//@{

    /** Smallest element of the map (wrt. the partial ordering on DomainT).
        first() does not exist for continuous datatypes and open interval bounds.
    */
    DomainT first()const { return (*(_map.begin())).KEY_VALUE.first(); }  // JODO NONCONT

    /** Largest element of the map (wrt. the partial ordering on DomainT).
        first() does not exist for continuous datatypes and open interval bounds.
    */
    DomainT last()const { return (*(_map.rbegin())).KEY_VALUE.last(); } // JODO NONCONT


    /** Number of elements in the set (cardinality). 
        Infinite for continuous domain datatyps    */
    size_type cardinality()const;

    /// An interval set's size is it's cardinality
    size_type size()const { return cardinality(); }

    difference_type length()const;


    /** Sum of associated elements of the map
        <b>Nicht getestet</b> */
    CodomainT sum()const;

    /**    Set interval bounds to the type <tt>bt</tt> for intervals in the map.

        Interval bounds of different types are created by opeations on
        interval maps. This function allows to reset them uniformly without,
        of course, changing their value. This is only possible for discrete
        domain datatypes.
    */
    void uniformBounds( typename interval<DomainT>::bound_types bt);

    void closeLeftBounds();
//@}

    void recJoin();


    template<typename IteratorT>
    static const key_type& key_value(IteratorT& value_){ return (*value_).first; }

    template<typename IteratorT>
    static const data_type& data_value(IteratorT& value_){ return (*value_).second; }

    template<typename IteratorT>
    static codomain_type codomain_value(IteratorT& value_){ return (*value_).second; }

    template<typename LeftIterT, typename RightIterT>
    static bool key_less(LeftIterT& lhs_, RightIterT& rhs_) { return key_compare()((*lhs_).first, (*rhs_).first); }

    static value_type make_domain_element(const domain_type& dom_val, const codomain_type& codom_val)
    { return value_type(interval_type(dom_val), codom_val); }

protected:
    sub_type* that() { return static_cast<sub_type*>(this); }
    const sub_type* that()const { return static_cast<const sub_type*>(this); }

protected:
    ImplMapT _map;
} ;



template 
<
    class SubType, class DomainT, class CodomainT, class Traits, 
    template<class>class Interval, template<class>class Compare, 
    template<class>class Alloc
>
typename interval_base_map<SubType,DomainT,CodomainT,Traits,
                           Interval,Compare,Alloc>::size_type 
interval_base_map<SubType,DomainT,CodomainT,Traits,
                  Interval,Compare,Alloc>::cardinality()const
{
    using namespace boost::mpl;
    return if_<
                bool_<is_continuous<DomainT>::value>,
                continuous_interval_container,
                discrete_interval_container
              >
              ::type::cardinality(*this);
}

template 
<
    class SubType, class DomainT, class CodomainT, class Traits, 
    template<class>class Interval, template<class>class Compare, 
    template<class>class Alloc
>
typename interval_base_map<SubType,DomainT,CodomainT,Traits,
                           Interval,Compare,Alloc>::difference_type 
interval_base_map<SubType,DomainT,CodomainT,Traits,
                  Interval,Compare,Alloc>::length()const
{
    difference_type length = neutron<difference_type>::value();
    const_FOR_IMPLMAP(it)
        length += (*it).KEY_VALUE.length();
    return length;
}




template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
bool interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::contained_in(const interval_base_map& super)const
{
    // x2 should be larger than *this; so every element in this should be in x2
    const_FOR_IMPLMAP(it) 
        if(!super.that()->contains_(*it)) 
            return false;
    return true;
}


template 
<
    class SubType,
    class DomainT, class CodomainT, 
    class Traits, template<class>class Interval, 
    template<class>class Compare, template<class>class Alloc
>
    template
    <
        template
        <    
            class DomT, class CodomT, 
            class Trts, template<class>class Interv, 
            template<class>class Comp, template<class>class Allc
        >
        class IntervalMap
    >
void interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>
    ::add_intersection
(
    interval_base_map& intersection,
    const IntervalMap<DomainT,CodomainT,Traits,Interval,Compare,Alloc>& sectant
)const
{
    typedef IntervalMap<DomainT,CodomainT,
                        Traits,Interval,Compare,Alloc> sectant_type;
    if(sectant.empty()) 
        return;
    typename sectant_type::const_iterator common_lwb;
    typename sectant_type::const_iterator common_upb;
    if(!Set::common_range(common_lwb, common_upb, sectant, *this))
        return;
    typename sectant_type::const_iterator it = common_lwb;
    while(it != common_upb)
        add_intersection(intersection, *it++);
}

template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
void interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>
    ::add_intersection(interval_base_map& section, 
                    const typename interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>
                    ::value_type& sectant)const
{
    interval_type sectant_interval = sectant.KEY_VALUE;
    if(sectant_interval.empty()) return;

    typename ImplMapT::const_iterator fst_it = _map.lower_bound(sectant_interval);
    typename ImplMapT::const_iterator end_it = _map.upper_bound(sectant_interval);

    for(typename ImplMapT::const_iterator it=fst_it; it != end_it; it++) 
    {
        interval_type common_interval; 
        (*it).KEY_VALUE.intersect(common_interval, sectant_interval);

        if(!common_interval.empty())
        {
            section.that()->add( value_type(common_interval, (*it).CONT_VALUE) );
            if(is_set<CodomainT>::value)
                section.that()->add<inplace_star>( value_type(common_interval, sectant.CONT_VALUE) );
            else
                section.that()->add<inplace_plus>( value_type(common_interval, sectant.CONT_VALUE) );
                //section.that()->add<inplace_identity>( value_type(common_interval, sectant.CONT_VALUE) );
        }
    }
}


template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
void interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>
    ::add_intersection(interval_base_map& section, 
                    const typename interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>
                    ::interval_type& sectant_interval)const
{
    if(sectant_interval.empty()) return;

    typename ImplMapT::const_iterator fst_it = _map.lower_bound(sectant_interval);
    typename ImplMapT::const_iterator end_it = _map.upper_bound(sectant_interval);

    for(typename ImplMapT::const_iterator it=fst_it; it != end_it; it++) 
    {
        interval_type common_interval; 
        (*it).KEY_VALUE.intersect(common_interval, sectant_interval);

        if(!common_interval.empty())
            section.that()->add( value_type(common_interval, (*it).CONT_VALUE) );
    }
}



template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>
    ::join()
{
    iterator it=_map.begin();
    if(it==_map.end()) 
        return *this;

    iterator nxt=it; nxt++;
    if(nxt==_map.end()) 
        return *this;

    while(nxt != _map.end())
    {
        if(    (*it).KEY_VALUE.touches((*nxt).KEY_VALUE)
            && (*it).CONT_VALUE == (*nxt).CONT_VALUE      )
        {
            iterator fst_mem = it;  // hold the fist member
            
            // go noodling on while touchin members found
            it++; nxt++;
            while(     nxt != _map.end()
                    && (*it).KEY_VALUE.touches((*nxt).KEY_VALUE)
                    && (*it).CONT_VALUE == (*nxt).CONT_VALUE     ) //CodomainT::OP ==
            { it++; nxt++; }

            // finally we arrive at the end of a sequence of joinable intervals
            // and it points to the last member of that sequence
            iterator lst_mem = it, end_mem = nxt;
            interval_type joinedInterval((*fst_mem).KEY_VALUE);
            joinedInterval.extend((*lst_mem).KEY_VALUE);
            CodomainT value = (*fst_mem).CONT_VALUE; //CodomainT::OP =
            
            _map.erase(fst_mem, end_mem);
            it = _map.insert(value_type(joinedInterval, value)).ITERATOR;

            it++; // go on for the next after the currently inserted
            nxt=it; if(nxt!=_map.end())nxt++;
        }
        else { it++; nxt++; }
    }
    return *this;
}


template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
std::string interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::as_string()const
{
    std::string res(""); 
    const_FOR_IMPLMAP(it) {
        std::string cur("("); 
        cur += (*it).KEY_VALUE.as_string();
        cur += ",";
        cur += itl::to_string<CodomainT>::apply((*it).CONT_VALUE);
        cur += ")";
        res += cur;
    }
    return res; 
}


template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
CodomainT interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::sum()const
{
    CodomainT sum = CodomainT();
    const_FOR_IMPLMAP(it) 
        sum += (*it).CONT_VALUE;
    return sum;
}


template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
void interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::uniformBounds( typename interval<DomainT>::bound_types bt)
{
    // I can do this only, because I am shure that the contents and the
    // ordering < on interval is invariant wrt. this transformation on bounds
    FOR_IMPLMAP(it) const_cast<interval_type&>((*it).KEY_VALUE).transformBounds(bt);
}

template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
void interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>::closeLeftBounds()
{
    // I can do this only, because I am shure that the contents and the
    // ordering < on interval is invariant wrt. this transformation on bounds
    FOR_IMPLMAP(it) const_cast<interval_type&>((*it).KEY_VALUE).closeLeftBound();
}



template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
SubType& interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>
    ::erase(const interval_type& x_itv)
{
    if(x_itv.empty()) return *that();
    iterator fst_it = _map.lower_bound(x_itv);
    if(fst_it==_map.end()) return *that();
    iterator end_it = _map.upper_bound(x_itv);
    
    typename ImplMapT::iterator it=fst_it, nxt_it=fst_it, victim;
    interval_type leftResid;   // left residual from first overlapping interval of *this
    (*it).KEY_VALUE.left_surplus(leftResid,x_itv);
    interval_type rightResid;  // right residual from last overlapping interval of *this
    
    CodomainT leftResid_ContVal = (*it).CONT_VALUE;
    CodomainT rightResid_ContVal;
    
    while(it!=end_it)
    { 
        if((++nxt_it)==end_it) 
        {
            (*it).KEY_VALUE.right_surplus(rightResid,x_itv);
            rightResid_ContVal = (*it).CONT_VALUE;
        }
        victim = it; it++; _map.erase(victim);
    }
    
    that()->add_(value_type(leftResid,  leftResid_ContVal));
    that()->add_(value_type(rightResid, rightResid_ContVal));

    return *that();
}


template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
SubType& 
interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>
    ::erase(const interval_base_map& erasure)
{
    const_FORALL(typename interval_base_map, value_pair_, erasure)
        that()->erase_(*value_pair_);

    return *that();
}

//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
// itl::global function templates
//-----------------------------------------------------------------------------
//-----------------------------------------------------------------------------
    
//-----------------------------------------------------------------------------
// equality
//-----------------------------------------------------------------------------
template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
inline bool operator == (const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& lhs,
                         const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& rhs)
{
    //MEMO PORT: This implemetation worked with stlport, sgi and gnu 
    // implementations of the stl. But using MSVC-implementation
    // results in runtime error! So I had to provide an independent
    // safe implemetation.
    //return std::equal(lhs.begin(), lhs.end(), rhs.begin());
    return Set::lexicographical_equal(lhs, rhs);
}

template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
inline bool is_protonic_equal(const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& lhs,
                              const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& rhs)
{
    interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc> lhs0 = lhs;
    interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc> rhs0 = rhs;

    lhs0.absorb_neutrons();
    rhs0.absorb_neutrons();

    return Set::lexicographical_equal(lhs0, rhs0);
}


template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
inline bool is_element_equal(const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& lhs,
                             const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& rhs)
{
    interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc> lhs_joined = lhs;
    interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc> rhs_joined = rhs;

    lhs_joined.join();
    rhs_joined.join();

    return Set::lexicographical_equal(lhs_joined, rhs_joined);
}


//-----------------------------------------------------------------------------
// order
//-----------------------------------------------------------------------------
template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
inline bool operator < (const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& lhs,
                        const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& rhs)
{
    return std::lexicographical_compare(
        lhs.begin(), lhs.end(), rhs.begin(), rhs.end(), 
        Compare<std::pair<Interval<DomainT>, CodomainT> >()
        );
}

template 
<
    class SubType,
    class DomainT, class CodomainT, class Traits, template<class>class Interval, template<class>class Compare, template<class>class Alloc
>
inline bool operator <= (const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& lhs,
                        const interval_base_map<SubType,DomainT,CodomainT,Traits,Interval,Compare,Alloc>& rhs)
{
    return lhs < rhs || lhs == rhs;
}

//-----------------------------------------------------------------------------
// min, max
//-----------------------------------------------------------------------------
template 
<
    class SubType,
    class DomainT, class CodomainT, 
    class Traits, template<class>class Interval, 
    template<class>class Compare, template<class>class Alloc
>
interval_base_map<SubType,DomainT,CodomainT,
                  Traits,Interval,Compare,Alloc>& 
min_assign
(
          interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& object,
    const interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& operand
)
{
    typedef interval_base_map<SubType,DomainT,CodomainT,Traits,
                              Interval,Compare,Alloc>    map_type;
    const_FORALL(typename map_type, elem_, operand) 
        object.template add<inplace_min >(*elem_); 

    return object; 
}

template 
<
    class SubType,
    class DomainT, class CodomainT, 
    class Traits, template<class>class Interval, 
    template<class>class Compare, template<class>class Alloc
>
interval_base_map<SubType,DomainT,CodomainT,
                  Traits,Interval,Compare,Alloc>& 
max_assign
(
          interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& object,
    const interval_base_map<SubType,DomainT,CodomainT,
                            Traits,Interval,Compare,Alloc>& operand
)
{
    typedef interval_base_map<SubType,DomainT,CodomainT,Traits,
                              Interval,Compare,Alloc>    map_type;
    const_FORALL(typename map_type, elem_, operand) 
        object.template add<inplace_max>(*elem_); 

    return object; 
}

//---------------------------------------------------------------------------------

template<class CharType, class CharTraits, 
    class SubType, class DomainT, class CodomainT, class Traits, 
    template<class>class Interval, template<class>class Compare, 
    template<class>class Alloc>
std::basic_ostream<CharType, CharTraits>& operator <<
  (std::basic_ostream<CharType, CharTraits>& stream, 
   const interval_base_map<SubType,DomainT,CodomainT,Traits,
                           Interval,Compare,Alloc>& object)
{
    typedef interval_base_map<SubType,DomainT,CodomainT,Traits,
                              Interval,Compare,Alloc> IntervalMapT;
    stream << "{";
    const_FORALL(typename IntervalMapT, it, object)
        stream << "(" << (*it).KEY_VALUE << "->" << (*it).CONT_VALUE << ")";

    return stream << "}";
}

}} // namespace itl boost

#endif


