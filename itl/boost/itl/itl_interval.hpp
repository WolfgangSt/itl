/*----------------------------------------------------------------------------+
Copyright (c) 2007-2008: Joachim Faulhaber
+-----------------------------------------------------------------------------+
Copyright (c) 1999-2006: Cortex Software GmbH, Kantstrasse 57, Berlin
+-----------------------------------------------------------------------------+
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
+----------------------------------------------------------------------------*/
#ifndef __itl_interval_JOFA_000626_H__
#define __itl_interval_JOFA_000626_H__

#include <functional>
#include <limits>
#include <string>
#include <boost/call_traits.hpp> 
#include <boost/mpl/bool.hpp> 
#include <boost/mpl/if.hpp> 
#include <itl/type_traits/is_continuous.hpp>
#include <itl/itl_type.hpp>
#include <itl/itl_value.hpp>

#undef min
#undef max

#define BOUND_VAL first
#define BOUND_TYPES second

typedef unsigned char ITV_BOUNDTYPES;

namespace itl
{

/**
    \mainpage The Interval Template Library

    \section news_sec News

    New examples are available showing applications of interval containers
    that use boost::date_time. Boost::gregorian dates and boost::posix times
    are used in examples boost_party.cpp, man_power.cpp, user_groups.cpp
    and month_and_week_grid.cpp.

    \section intro_sec Introduction

    The Interval Template Library (ITL) is a collection of
    generic c++ template classes for computations on <em>collections of
    intervals</em>. The most important instance of their use is the computation
    with containers of time intervals that are associated to values. We call
    such containers \e histories and their elements \e episodes. In addition to
    intervals and interval containers the library provides classes for
    generalized crosstables, which are tuple containers. We call such
    containers <em>tuple computers</em> or \e cubes.
    \n \n
    The Interval Template Library is currently hosted at the open source
    platform sourceforge and can be downloaded from http://sourceforge.net/projects/itl .
    This doxygen generated html documentation is part of the library release.
    In addition it is available at http://www.herold-faulhaber.de/itl .
    \n \n
    Basic parts of the ITL (interval conainers) are currently discussed at the
    boost developers mailing list as a contribution to the boost libraries.
    Although the sourcecode of the ITL is mature and very well tested it's 
    design may be refactored significantly in a process of adapting to the
    boost library design principles and coding standards.
    \n \n \n

    \section sample_sec Examples

    We do provide a collection of examples that demonstrate the purpose and basic
    characteristics of the classes offered by the library. To get an instant 
    impression you may browse these examples first.
    \n \n \n

    \subsection party_subsec Party

    boost_party.cpp is the ITL's <em>flagship example</em> because it demonstrates
    at least two important aspects of the library design in a 
    comprehensible way.
    In boost_party.cpp the change of guests of a party in time is calculated using
    an interval_map simply by adding pairs of intervals and guest sets
    to the interval_map. As can be seen from this example interval_map has a 
    <em>decompositional behavior</em> on the time part: time intervals are
    split up whenever the set of guests is changing. And it has an 
    <em>aggregational behavior</em> on the associated values: Guest sets are 
    added up on insertion. (party.cpp is a variant of the example that does not use 
    boost::date_time).
    \n \n

    \subsection interval_subsec Intervals 
    
    Interval.cpp gives a short example of different instances of the class interval
    \n \n

    \subsection interval_container_subsec Interval container

    Sample interval_container.cpp demonstrates basic charactersistics of 
    interval container objects: interval_set, split_interval_set and split_interval_map.
    \n \n

    \subsection month_and_week_grid Partitioning of times using split_interval_set

    Example month_and_week_grid.cpp shows how the <em>border preserving</em>
    split_interval_set can be used to create time partitionigs where different
    periodic time intervals overlay each other. The example uses boost::date_time.
    \n \n



    \subsection overlap_counter_subsec Overlap counter: The most basic interval_map application

    The most basic application of an interval_map is a counter counting
    the number of overlaps of intervals inserted into it as shown in overlap_counter.cpp.
    \n \n

    \subsection man_power Man-power: Set operations on interval containers

    Set style operations on interval_sets and interval_maps like union, difference
    and intersection can be used to obtain calculations in a flexible way. Example
    man_power.cpp demontrates such operations in the process of calculating the
    available man-power of a company in a given time interval. The example uses 
    boost::date_time.
    \n \n

    \subsection history_subsec History

    History is a more sophisticated application of an interval_map to decompose
    data in time. Sample history.cpp shows how we can monitor a set of attributes in a history.
    \n \n


    \subsection user_groups_subsec User Groups: Union and intersecion of histories

    Example user_groups.cpp shows how interval_maps can be unified (+=) or 
    intersected    (*=) to calculate desired informations. We have a group of
    admin users and    of medcial staff, who have different authorisations in
    a ficticious system. The interval_maps for
    the groups show the history of the group membership: The members
    and how they change in time. The union of the groups is a 
    history that shows the memberships of employees who have
    any rights (admin or medical). And the intersection represents the
    group of employees who have both rights: The superusers.


    \subsection amount_cube_subsec Amount cube

    Cubes or tuple computers allow to perform computations on values associated 
    to tuples. A ITL tuple computer works similar to pivot tables (in spreadsheet programs)
    olap cubes (online analytic    processing) or crosstables (in statistical programs). 
    Sample amount_cube.cpp presents an application where values are \e 'amounts', 
    which is the simplest instance.
    \n \n \n

    \section content_sec Content of the ITL 

    \subsection itv_subsec Intervals and sets of intervals 

    A set of intervals represents again a set. The implementation of a set as a set of
    intervals is a very efficient implementation of a set if it's elements are
    clustered in intervals. Examples for interval sets are given in sample
    interval_container.cpp. 
    \n \n

    \subsection aov_subsec Interval maps and 'aggregation on overlap' 

    On of the most fruitful concept of the ITL is the <em>aggregation on overlap</em>
    mechanism on interval maps. The associated values of an interval map are 
    aggregated on insertion, whenever an interval value pair is added and
    the added interval overlaps intervals within the map. Depending on the value
    type this aggregation can be summation (for numbers), concatentation 
    (for lists, strings), set union (for sets) and more. Samples of the 
    <em>aggreation on overlap</em> mechanics are demonstrated in
    files boost_party.cpp (party.cpp), overlap_counter.cpp, man_power.cpp 
    and history.cpp.
    \n \n \n

    \subsection itv_cont_subsec Overview over interval containers 

    Interval containers are sets or maps that are implemented as sets or maps of
    intervals. They are efficient and useful containers in all problem domains
    where elements of sets apperar in continguous chunks (intervals).

    The design of the itl provides five kinds of interval containers: 3 set
    class templates and 2 map class templated. The above table presents an
    overview over interval containers:

    <table>
        <tr>
            <th></td>
            <th>joining</td>
            <th>separating</td>    
            <th>splitting</td>       
        </tr>
        <tr>
            <td>set</td>
            <td>interval_set</td>
            <td>separate_interval_set</td>    
            <td>split_interval_set</td>       
        </tr>
        <tr>
            <td>map</td>
            <td>interval_map</td>
            <td></td>                   
            <td>split_interval_map</td>
        </tr>
        <tr>
            <td></td>
            <td><em>intervals are joined on overlap or touch<br>
                    (if associated values are equal)</em></td>
            <td><em>intervals are joined on overlap, not on touch</em></td>                   
            <td><em>intervals are split on overlap.<br>All interval borders are thus preserved</em></td>
        </tr>
        <tr>
            <td></td><td colspan=3 align="center">
                The different behavior of interval_containers is clarified 
                in interval_container_conduct.h by example.
            </td>
        </tr>
    </table>

    Aspects of the interval container's desing are presented in interval_container_design.h .


    \subsection decom_subsec Decomposition of Histories

    Using interval maps we can build a so called <em>product history</em>, 
    where a product of attributes (or objects) is associated to intervals
    and then inserted to a history. A product history keeps itself always
    in a normal form. Whenever any of the attributes changes, the intervals
    are split such that all attributes associated to an interval are constant.
    So here we get a general mechanism for decomposition of (time) intervals for
    the change of monitored attributes. An example for product histories is
    given in file history.cpp. 
    \n \n


    \subsection cubes_subsec Cubes 

    Tuple computer or cubes are implemented as maps of tuples in the ITL. 
    Cubes are known as crosstables from statistical packages, OLAP 
    (online analytic processing) cubes from data warehouse technology 
    and pivot tables from spradsheet programs (e.g. excel). In the ITL 
    we offer a generic implementation of such cubes in c++. Aggregation
    (e.g. summation) can be expressed by omitting elements of the tuple 
    type of the cube, which we call projection. Other things like grouping
    and sorting can be done quite elegantly. An example for cubes is 
    provided by file amount_cube.cpp. 
    \n \n

    \section thanks_sec Acknowledgements

    I would like to thank CEO Hermann Steppe and Chief Developer Peter Wuttke
    of Cortex Software GmbH for their friendly support of my work on the
    ITL and their permission to release the    library as open source.
    
*/

/// A class for intervals
/**    Bounds of the interval may be closed or open.
    Discrete or continuous datatypes may be used as domain datatypes DataT.

       Template parameter <b>DataT</b>:
    The intervals domain type or type of the elements of the interval.
    The interface <b>DataT</b> has to be implemented by any actual template
    parameter.

    The class defines intervals with closed or open bounds for discrete
    <tt>(short, int, date, time etc.)</tt> and continuous 
    <tt>float, double, Rational, Complex etc.</tt> elements. The domain parameter
    may be a built in c++ datatype or a class type. It has to implement
    the interface DataT.

    @author  Joachim Faulhaber
*/
template <class DataT>
class interval
{
public:

/** @name A: Type definitions for the template class 
*/
//@{ 
    /// Domain type or element type
    typedef DataT data_type;

    /// Interval bounds as bitset
    typedef unsigned char bound_types;

    /// Constants for intervalbounds
    enum BoundTypesT {
        /// Both open: <tt>(x,y)</tt>
        OPEN                     = 0x0, 
        /// Left open right closed: <tt>(x,y]</tt>
        LEFT_OPEN                = 0x1, 
        /// Left closed right open: <tt>[x,y)</tt>
        RIGHT_OPEN               = 0x2,
        /// Both closed: <tt>[x,y]</tt>
        CLOSED                   = 0x3,
    } ;

    // public?
    typedef std::pair<DataT, bound_types> BoundT;
//@}


    // JODO unon() dokumentieren
    /// Default constructor; yields an empty interval <tt>[1,0]</tt>
    interval() : _lwb(type<DataT>::unon()), _upb(type<DataT>::neutron()), 
                 _boundtypes(CLOSED) {}
    /// Constructor for a closed singleton interval <tt>[val,val]</tt>
    interval(const DataT& val) : 
        _lwb(val), _upb(val), _boundtypes(CLOSED) {}
    /// Closed interval <tt>[lw,up]</tt>
    interval(const DataT& lw, const DataT& up) : 
        _lwb(lw), _upb(up), _boundtypes(CLOSED) {}
    /// Interval from <tt>lw</tt> to <tt>up</tt> with bounds <tt>bt</tt> 
    interval(const DataT& lw, const DataT& up, bound_types bt) : 
        _lwb(lw), _upb(up), _boundtypes(bt) {}


/** @name E: Selectors
*/
//@{
    /// Lower bound of the interval
    DataT lower()const { return _lwb; }
    /// Upper bound of the interval
    DataT upper()const { return _upb; }
    /// Typ of interval bounds
    bound_types boundtypes()const { return _boundtypes; }
//@}

/** @name F.P: Tester, predicates
*/
//@{
    /// Is the interval empty?
    bool empty()const;
    /// Does the interval contain <tt>x</tt>?
    bool contains(const DataT& x)const;

    /// Both closed: <tt>[x,y]</tt> ?
    bool is_closed()const { return _boundtypes == CLOSED; }
    /// Left open right closed: <tt>(x,y]</tt> ?
    bool is_leftopen()const  { return _boundtypes == LEFT_OPEN; }
    /// Left closed right open: <tt>[x,y)</tt> ?
    bool is_rightopen()const  { return _boundtypes == RIGHT_OPEN; }
    /// Both open: <tt>(x,y)</tt> ?
    bool is_open()const   { return _boundtypes == OPEN; }

    /// Left bound is open right unknown <tt>(x,y|</tt> ?
    bool leftbound_open()const { return !leftbound_closed(); }
    //CL bool leftbound_open()const { return !leftbound_closed(); }

    /// Right bound is open left unknown <tt>|x,y)</tt> ?
    bool rightbound_open()const { return !rightbound_closed(); }
    //CL bool rightbound_open()const { return !rightbound_closed(); }

    /// Left closed right unknown <tt>[x,y|</tt> ?
    bool leftbound_closed()const { return 0 != (_boundtypes & RIGHT_OPEN); }
    //CL bool leftbound_closed()const { return 0 != (_boundtypes & RIGHT_OPEN); }

    /// Right closed left unknown <tt>|x,y]</tt> ?
    bool rightbound_closed()const { return 0 != (_boundtypes & LEFT_OPEN); }
    //CL bool rightbound_closed()const { return 0 != (_boundtypes & LEFT_OPEN); }

//@}

/** @name F.R: Tester, relations
*/
//@{

    /// <tt>*this</tt> is subset of <tt>super</tt>
    bool contained_in(const interval& super)const ;
    /// Equality
    bool equal(const interval& x2)const
    { return contained_in(x2) && x2.contained_in(*this); } //JODO direct implementation via lwb_equal and upb_equal, then test of correctness
    /// Equality operator
    //CL bool operator == (const interval& x2)const { return isEqual(x2); }


    ///  <tt>*this</tt> and <tt>x2</tt> are disjoint; their intersection is empty
    bool disjoint_to(const interval& x2)const
    { return exclusive_less(x2) || x2.exclusive_less(*this); }
    /// There is no gap between <tt>*this</tt> and <tt>x2</tt> but they have no element in common
    bool touches(const interval& x2)const;

    /// Exclusive less: maximal element of <tt>*this</tt> is less than the minimal element of <tt>x2</tt>
    bool exclusive_less(const interval& x2)const;

    bool less(const interval& x2)const
    { return lwb_less(x2) || ( lwb_equal(x2) && upb_less(x2) ); }

//@}


/** @name G: Modificators
*/
//@{
    /// Set the interval empty
    void clear()
    { set_lwb(type<DataT>::unon()); set_upb(type<DataT>::neutron()); _boundtypes=CLOSED; }

    /// Set the intervals values
    interval& set(const DataT& lw, const DataT& up, bound_types bt) 
    { _lwb=lw; _upb=up; _boundtypes=bt; return *this; }

    /** Extend <tt>*this</tt> to <tt>x2</tt> yielding an interval from the minimum of lower bounds
        to the maximum of upper bounds */
    interval& extend(const interval& x2);

    /** scaleUp the unit of an Interval to a finer degree. To scale up from days to minutes
        call scaleUp(Time::minutes_per_day, Time::maxMinutes_inDays).
        The second parameter 'max' gives the maximum value of the old scale that can be
        represented in the new finer scale.
    */
    interval& scale_up(DataT factor, DataT max);

    /** scaleDown the unit of an Interval to a rougher degree. To scale down from minutes to days.
        Call scaleDown(Time::minutes_per_day). */
    interval& scale_down(DataT factor);
//@}


/** @name H: Combinators and more
*/
//@{
    /// Intersection with the interval  <tt>x2</tt>; assign result to <tt>isec</tt>
    void intersect(interval& isec, const interval& x2)const;

    /// Returns the intersection with the interval  <tt>x2</tt>
    interval intersect(const interval& x2)const { interval isec; intersect(isec, x2); return isec; }

    // wenn <tt>*this</tt> links über <tt>x2</tt> herausragt, ist <tt>lsur</tt> das überstehende linke Teilintervall
    ///
    void left_surplus(interval& lsur, const interval& x2)const;
    // wenn <tt>*this</tt> rechts über <tt>x2</tt> herausragt, ist <tt>rsur</tt> das überstehende rechte Teilintervall
    ///
    void right_surplus(interval& rsur, const interval& x2)const;

    /** Interval spanning from lower bound of *this interval to the upper bound of rhs.
        Bordertypes according to the lower bound of *this and the upper bound of rhs.
    */
    interval span(const interval& rhs)const
    { return interval(_lwb, rhs._upb, span(boundtypes(), rhs.boundtypes()));    }

    interval& left_subtract(const interval& x2);
//@}


/** @name S: String representation
    */
//@{
    /// Interval as string
    const std::string as_string()const;
//@}


    // NOTE ------- DISCRETE ONLY ------- DISCRETE ONLY ------- DISCRETE ONLY ------- 
/** @name T: For discrete domain datatypes only that implement operators <tt>++</tt> 
        and <tt>--</tt>
    */
//@{
    /// First (smallest) element of the interval
    DataT first()const;
    /// Last (largest) element of the interval
    DataT last()const;

	/// Cardinality of the interval: The number of elements
	std::size_t cardinality()const;

	/// Arithmetic size of the interval
	DataT length()const;

    /// Size of the interval
    DataT size()const;

    /// <tt>*this</tt> interval as closed <tt>[x,y]</tt> interval
    interval as_closed_interval()const;
    /// <tt>*this</tt> interval as open  <tt>[x,y]</tt> interval
    interval as_rightopen_interval()const;

    /** Transforms the interval to the bound-type <tt>bound_types bt</tt> without
        changing it's content
    */
    void transform_bounds(bound_types bt);

    /** Sets left border closed. */
    void close_left_bound();

    /** Sets right border open. */
    void open_right_bound();
    
//@}

/** @name U: Utilities and Limits
    */
//@{
    /// Maximum Interval
    static interval always()
    { return closed_interval(std::numeric_limits<DataT>::min(), 
                             std::numeric_limits<DataT>::max()); }
//@}

    void set_lwb(DataT lw) { _lwb=lw; }
    void set_upb(DataT up) { _upb=up; }

private:

    void set_lwb_type(bound_types bt) 
    { _boundtypes = (unsigned char)((LEFT_OPEN & _boundtypes) | (RIGHT_OPEN & bt)); }

    void set_upb_type(bound_types bt) 
    { _boundtypes = (unsigned char)((RIGHT_OPEN & _boundtypes) | (LEFT_OPEN & bt)); }

    static bound_types span(bound_types left, bound_types right)
    { return (unsigned char)((LEFT_OPEN | left) & (RIGHT_OPEN | right)) ; }

    bound_types succession_bounds()const;

    void set_lwb(const BoundT& lw) { _lwb=lw.BOUND_VAL; set_lwb_type(lw.BOUND_TYPES); }
    void set_upb(const BoundT& up) { _upb=up.BOUND_VAL; set_upb_type(up.BOUND_TYPES); }

    bool lwb_less(const interval& x2)const;
    bool upb_less(const interval& x2)const;
    bool lwb_less_equal(const interval& x2)const;
    bool upb_less_equal(const interval& x2)const;
    bool lwb_equal(const interval& x2)const;
    bool upb_equal(const interval& x2)const;

    BoundT lwb_min(const interval& x2)const;
    BoundT lwb_max(const interval& x2)const;
    BoundT upb_min(const interval& x2)const;
    BoundT upb_max(const interval& x2)const;

    BoundT lwb_rightOf(const interval& x2)const;
    BoundT upb_leftOf(const interval& x2)const;

private:
    DataT _lwb;
    DataT _upb;
    bound_types _boundtypes;
} ;




template <class DataT>
interval<DataT> closed_interval(const DataT& lwb, const DataT& upb)
{ return interval<DataT>(lwb, upb, interval<DataT>::CLOSED); }

template <class DataT>
interval<DataT> leftopen_interval(const DataT& lwb, const DataT& upb)
{ return interval<DataT>(lwb, upb, interval<DataT>::LEFT_OPEN); }

template <class DataT>
interval<DataT> rightopen_interval(const DataT& lwb, const DataT& upb)
{ return interval<DataT>(lwb, upb, interval<DataT>::RIGHT_OPEN); }

template <class DataT>
interval<DataT> open_interval(const DataT& lwb, const DataT& upb)
{ return interval<DataT>(lwb, upb, interval<DataT>::OPEN); }




template <class DataT>
typename interval<DataT>::bound_types interval<DataT>::succession_bounds()const
{
    if(_boundtypes==RIGHT_OPEN) return RIGHT_OPEN;
    if(_boundtypes==LEFT_OPEN)  return LEFT_OPEN;
    if(_boundtypes==CLOSED)     return OPEN;
    return CLOSED;
}


template <class DataT>
bool interval<DataT>::empty()const
{
	using namespace boost::mpl;

    if(rightbound_closed() && leftbound_closed()) return _upb <  _lwb;
    if(rightbound_open()   && leftbound_closed()) return _upb <= _lwb;
    if(rightbound_closed() && leftbound_open())   return _upb <= _lwb;

    // OTHERWISE (rightbound_open() && leftbound_open())
	return 
		if_<
			bool_<is_continuous<DataT>::value>, 
			continuous_type<DataT>, 
			discrete_type<DataT> 
		   >
		   ::type::open_bound_less(_lwb, _upb);
}

template<class DataT> 
struct continuous_type
{
	typedef typename boost::call_traits<DataT>::param_type DataP;
	static bool open_bound_less(DataP lwb, DataP upb) { return upb <= lwb; }
};

template<class DataT> 
struct discrete_type
{
	typedef typename boost::call_traits<DataT>::param_type DataP;

	static bool open_bound_less(DataP lwb, DataP upb) 
	{ return upb <= succ(lwb); }

	static std::size_t cardinality(DataP first, DataP last) 
	{ return last-first + type<DataT>::unon(); }
};

template<class DataT> 
struct continuous_interval
{
	static std::size_t cardinality(const interval<DataT>& x) 
	{ return std::numeric_limits<size_t>::infinity(); }

	static DataT length(const interval<DataT>& x) 
	{ return x.upper() - x.lower(); }
};

template<class DataT> 
struct discrete_interval
{
	static std::size_t cardinality(const interval<DataT>& x) 
	{ return succ(x.last() - x.first()); }

	static DataT length(const interval<DataT>& x) 
	{ return x.last() - x.first(); }
};

// NOTE structural similarities between empty and exclusive_less! 
// emptieness can be defined as being exclusive less to oneself.
template <class DataT>
bool interval<DataT>::exclusive_less(const interval& x2)const
{
    if(rightbound_closed() && x2.leftbound_closed()) return _upb <  x2._lwb;
    if(rightbound_open()   && x2.leftbound_closed()) return _upb <= x2._lwb;
    if(rightbound_closed() && x2.leftbound_open() )  return _upb <= x2._lwb;

    // OTHERWISE (rightbound_open()  && x2.leftbound_open())
    if(type<DataT>::is_continuous())   
                                                     return _upb <= x2._lwb;
                                                else return _upb <= succ(x2._lwb);
}


template <class DataT>
bool interval<DataT>::lwb_less(const interval& x2)const
{
    if(leftbound_closed() && x2.leftbound_closed()) return _lwb <  x2._lwb;
    if(leftbound_open()   && x2.leftbound_open())   return _lwb <  x2._lwb;
    if(leftbound_closed() && x2.leftbound_open())   return _lwb <= x2._lwb;

    // OTHERWISE (leftbound_open()  && x2.leftbound_closed())
    if(type<DataT>::is_continuous())   
                                    return       _lwb <  x2._lwb;
                               else return succ(_lwb) <  x2._lwb;
}

template <class DataT>
bool interval<DataT>::upb_less(const interval& x2)const
{
    if(rightbound_closed() && x2.rightbound_closed()) return _upb <  x2._upb;
    if(rightbound_open()   && x2.rightbound_open())   return _upb <  x2._upb;
    if(rightbound_open()   && x2.rightbound_closed()) return _upb <= x2._upb;

    // OTHERWISE (rightbound_closed()  && x2.rightbound_open())
    if(type<DataT>::is_continuous())   
                                     return      _upb  <  x2._upb;
                                else return    succ(_upb) <  x2._upb;
}


template <class DataT>
bool interval<DataT>::lwb_less_equal(const interval& x2)const
{
    if(leftbound_closed() && x2.leftbound_closed()) return _lwb <= x2._lwb;
    if(leftbound_open()  && x2.leftbound_open())  return _lwb <= x2._lwb;
    if(leftbound_open() &&  x2.leftbound_closed()) return _lwb <  x2._lwb;

    // OTHERWISE (leftbound_closed() && x2.leftbound_open())
    if(type<DataT>::is_continuous()) 
                                          return _lwb <= x2._lwb;
                                     else return _lwb <= succ(x2._lwb);
}


template <class DataT>
bool interval<DataT>::upb_less_equal(const interval& x2)const
{
    if(rightbound_closed() && x2.rightbound_closed()) return _upb <= x2._upb;
    if(rightbound_open()  && x2.rightbound_open())  return _upb <= x2._upb;
    if(rightbound_closed() && x2.rightbound_open())  return _upb <  x2._upb;

    // OTHERWISE (rightbound_open()  && x2.rightbound_closed())
    if(type<DataT>::is_continuous())   
                                            return _upb <= x2._upb;
                                       else return _upb <= succ(x2._upb);
}


//NOTE THINK: This implementation is rather interesting wrt. continuous value types.
// An alternative implementation was x.lwb_equal(y)={return x.lwb_less_equal(y) && y.lwb_less_equal(x)}
template <class DataT>
bool interval<DataT>::lwb_equal(const interval& x2)const
{
    if(leftbound_closed() && x2.leftbound_closed()) return _lwb == x2._lwb;
    if(leftbound_open()  && x2.leftbound_open())  return _lwb == x2._lwb;

    if(type<DataT>::is_continuous())
    {
        // mimimal (maximal) values of intervals of continuous values are never equal, if
        // they have different bound types. Interestingly this seems to be true only
        // in theory, because the very representations of doubles is discrete on a given
        // machine. We implement the theory here.
        return false;
    }
    else
    {
        if(leftbound_open() &&  x2.leftbound_closed()) 
             return succ(_lwb) ==      x2._lwb;
        else return      _lwb  == succ(x2._lwb);
    }
}

//NOTE THINK: This implementation is rather interesting wrt. continuous value types.
// An alternative implementation was x.lwb_equal(y)={return x.lwb_less_equal(y) && y.lwb_less_equal(x)}
template <class DataT>
bool interval<DataT>::upb_equal(const interval& x2)const
{
    if(rightbound_closed() && x2.rightbound_closed()) return _upb == x2._upb;
    if(rightbound_open()  && x2.rightbound_open())  return _upb == x2._upb;

    if(type<DataT>::is_continuous())
    {
        // mimimal (maximal) values of intervals of continuous values are never equal, if
        // they have different bound types. Interestingly this seems to be true only
        // in theory, because the very representations of doubles is discrete on a given
        // machine. We implement the theory here.
        return false;
    }
    else
    {
        if(rightbound_closed() && x2.rightbound_open())  
             return succ(_upb) ==      x2._upb;
        else return      _upb  == succ(x2._upb);
    }
}



template <class DataT>
typename interval<DataT>::BoundT interval<DataT>::lwb_min(const interval& x2)const
{
    if( x2.lwb_less(*this) )
        return BoundT(x2._lwb, x2.boundtypes());
    else
        return BoundT(_lwb, boundtypes());
}

template <class DataT>
typename interval<DataT>::BoundT interval<DataT>::upb_max(const interval& x2)const
{
    if( upb_less(x2) )
        return BoundT(x2._upb, x2.boundtypes());
    else
        return BoundT(_upb, boundtypes());
}


// JODO THINK URG do borders reverse when lwb_max is used as upb etc. ?
template <class DataT>
typename interval<DataT>::BoundT interval<DataT>::lwb_max(const interval& x2)const
{
    if( lwb_less(x2) )
        return BoundT(x2._lwb, x2.boundtypes());
    else
        return BoundT(_lwb, boundtypes());
}

template <class DataT>
typename interval<DataT>::BoundT interval<DataT>::upb_min(const interval& x2)const
{
    if( x2.upb_less(*this) )
        return BoundT(x2._upb, x2.boundtypes());
    else
        return BoundT(_upb, boundtypes());
}


template <class DataT>
typename interval<DataT>::BoundT interval<DataT>::upb_leftOf(const interval& x2)const
{
    return BoundT(x2._lwb, x2.succession_bounds());
}

template <class DataT>
typename interval<DataT>::BoundT interval<DataT>::lwb_rightOf(const interval& x2)const
{
    return BoundT(x2._upb, x2.succession_bounds());
}


// NOTE non symmetric version: *this[upb].touches(x2[lwb])   
template <class DataT>
bool interval<DataT>::touches(const interval& x2)const
{
    if(rightbound_open()  && x2.leftbound_closed()) return _upb == x2._lwb;
    if(rightbound_closed() && x2.leftbound_open())  return _upb == x2._lwb;

    if(type<DataT>::is_continuous()) {
        // ... sie konnten zusammen nicht kommen
        return false;
    } else {
        if(rightbound_closed() && x2.leftbound_closed()) return succ(_upb) == x2._lwb;
        if(rightbound_open()  && x2.leftbound_open() ) return _upb == succ(x2._lwb);
        return false;
    }
}

template <class DataT>
bool interval<DataT>::contains(const DataT& x)const
{
    if(rightbound_closed() && leftbound_closed()) return _lwb <= x && x <= _upb;
    if(rightbound_closed() && leftbound_open()  ) return _lwb <  x && x <= _upb;
    if(rightbound_open()   && leftbound_closed()) return _lwb <= x && x <  _upb;
                                                  return _lwb <  x && x <  _upb;
}

template <class DataT>
bool interval<DataT>::contained_in(const interval& super)const
{ return super.lwb_less_equal(*this) && upb_less_equal(super); }


template <class DataT>
interval<DataT>& interval<DataT>::extend(const interval<DataT>& x2)
{
    if(x2.empty()) return *this;
    else if(empty())
    {
        *this = x2; 
        return *this;
    }
    else 
    {
        set_lwb(lwb_min(x2));
        set_upb(upb_max(x2));
        return *this; 
    } 
}

template <class DataT>
interval<DataT>& interval<DataT>::scale_up(DataT factor, DataT max)
{
    if(empty())
        return *this;

    if(leftbound_open())
        if(_lwb >= max-1)
            _lwb = max*factor - 1;
        else
        {
            _lwb *= factor;
            _lwb += factor - 1;
        }
    else // leftbound_closed()
        if(_lwb >= max)
            _lwb = max * factor;
        else 
            _lwb *= factor;

    if(rightbound_closed())
        if(_upb >= max-1)
            _upb = max*factor - 1;
        else
        {
            _upb *= factor;
            _upb += factor - 1;
        }
    else
        if(_upb >= max)
            _upb = max * factor;
        else
            _upb *= factor;

    return *this;
}

template <class DataT>
interval<DataT>& interval<DataT>::scale_down(DataT factor)
{
    if(empty())
        return *this;
    _lwb /= factor;
    _upb /= factor;
    return *this;
}


template <class DataT>
interval<DataT>& interval<DataT>::left_subtract(const interval& x2)
{
    set_lwb( BoundT(x2._upb, x2.succession_bounds()) );
    return *this; 
}


template <class DataT>
void interval<DataT>::intersect(interval<DataT>& isec, const interval<DataT>& x2)const
{
    isec.set_lwb(lwb_max(x2));
    isec.set_upb(upb_min(x2));
}


template <class DataT>
void interval<DataT>::left_surplus(interval<DataT>& lsur, const interval<DataT>& x2)const
{
    if(lwb_less(x2)) {
        lsur.set_lwb( BoundT(_lwb,boundtypes()) ); 
        lsur.set_upb( upb_leftOf(x2) );   // (toUpb(pred(x2.first()))); 
    }
    else lsur.clear();
}

template <class DataT>
void interval<DataT>::right_surplus(interval<DataT>& rsur, const interval<DataT>& x2)const
{
    if(x2.upb_less(*this)) {
        rsur.set_lwb(lwb_rightOf(x2)); 
        rsur.set_upb( BoundT(_upb,boundtypes()) );
    }
    else rsur.clear();
}


template <class DataT>
const std::string interval<DataT>::as_string()const
{
    std::string itvRep("");
    std::string lwbRep, ubpRep;

    itvRep += leftbound_open() ? "(" : "[" ;
    // if(type<DataT>::is_atomic()) 
    {
        itvRep += itl::value<DataT>::to_string(_lwb);
        itvRep += ",";
        itvRep += itl::value<DataT>::to_string(_upb);

    }

    itvRep += rightbound_open() ? ")" : "]" ;

    return itvRep;
}


// NOTE ------- DISCRETE ONLY ------- DISCRETE ONLY ------- DISCRETE ONLY ------- 
// these functions do only compile with discrete DataT-Types that implement 
// operators ++ and --
// NOTE: they must be used in any function that is essential to all instances
// of DataT

template <class DataT>
DataT interval<DataT>::first()const
{ if(leftbound_closed()) return _lwb; else return succ(_lwb); }

template <class DataT>
DataT interval<DataT>::last()const
{ if(rightbound_closed()) return _upb; else return pred(_upb); }

template <class DataT>
std::size_t interval<DataT>::cardinality()const
{
	using namespace boost::mpl;
    if(empty()) 
        return 0;

	return if_<
				bool_<is_continuous<DataT>::value>,
				continuous_interval<DataT>,
				discrete_interval<DataT>
			  >
			  ::type::cardinality(*this);
}

template <class DataT>
DataT interval<DataT>::length()const
{
	using namespace boost::mpl;
    if(empty()) 
		return itl::type<DataT>::neutron();

	return if_<
				bool_<is_continuous<DataT>::value>,
				continuous_interval<DataT>,
				discrete_interval<DataT>
			  >
			  ::type::length(*this);
}


template <class DataT>
DataT interval<DataT>::size()const
{ 
    if(empty()) 
        return (type<DataT>::neutron() - type<DataT>::neutron()); 
    else if(type<DataT>::is_continuous()) 
        return _upb - _lwb;
    else 
        return last()-first() + type<DataT>::unon() - type<DataT>::neutron(); 
}

template <class DataT>
interval<DataT> interval<DataT>::as_closed_interval()const
{ return interval(first(), last(), CLOSED); }

template <class DataT>
interval<DataT> interval<DataT>::as_rightopen_interval()const
{ return interval(first(), pred(last()), RIGHT_OPEN); }

template <class DataT>
void interval<DataT>::transform_bounds(bound_types bt)
{ 
    switch(bt)
    {
    case CLOSED:    set(first(), last(), bt);                break;
    case RIGHT_OPEN:set(first(), succ(last()), bt);        break;
    case LEFT_OPEN: set(pred(first()), last(), bt);        break;
    case OPEN:        set(pred(first()), succ(last()), bt);    break;
    }
}

template <class DataT>
void interval<DataT>::close_left_bound()
{
    if(leftbound_open())
    {
        _boundtypes |= RIGHT_OPEN;
        _lwb++;
    }
}

template <class DataT>
void interval<DataT>::open_right_bound()
{
    if(rightbound_closed())
    {
        _boundtypes &= RIGHT_OPEN;
        _upb++;
    }
}



template <typename DataT>
inline bool operator == (const interval<DataT>& lhs, const interval<DataT>& rhs)
{
    return lhs.equal(rhs);
}

template <typename DataT>
inline bool operator < (const interval<DataT>& lhs, const interval<DataT>& rhs)
{
    return lhs.less(rhs);
}


/// Comparison functor on intervals implementing an overlap free less 
/**    
    <b>Template-Klasse exclusive_less: Comparison Functor for Intervals</b>

       Template parameter <b>IntervalType</b>: needs to implement the boolean function

    <tt>bool IntervalType::exclusive_less(IntervalType x2)const; </tt>
    
    <b>exclusive_less</b> implements a strict weak ordering that serves to
    sort sets and maps of intervals interval_set, split_interval_set and
    split_interval_map. 
    
    Function <tt>bool IntervalType::exclusive_less(IntervalType x2)const; </tt> is true if every
    element of the interval <tt>*this</tt> is less than any element of <tt>x2</tt>

    @author  Joachim Faulhaber
*/
template <class IntervalType>
struct exclusive_less {
    /** Operator <tt>operator()</tt> implements a strict weak ordering on intervals. */
    bool operator()(const IntervalType& x1, const IntervalType& x2)const
    { return x1.exclusive_less(x2); }
};

//JODO USENET: It is not a strict weak ordering because the induced equality in not 
// even an equivalence. Still the relation works completely well!

} // namespace itl

#endif


