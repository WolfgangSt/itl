/*----------------------------------------------------------------------------+
Copyright (c) 2007-2008: Joachim Faulhaber
+-----------------------------------------------------------------------------+
Copyright (c) 1999-2006: Cortex Software GmbH, Kantstrasse 57, Berlin
+-----------------------------------------------------------------------------+
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
+----------------------------------------------------------------------------*/
/* ------------------------------------------------------------------
class interval_set
--------------------------------------------------------------------*/
#ifndef __interval_set_h_JOFA_990223__
#define __interval_set_h_JOFA_990223__

#include <itl/interval_base_set.hpp>
#include <itl/j_assert.hpp>

namespace itl
{

/// Implements a set as a set of intervals - merging adjoining intervals
/**    
    Template-class <b>interval_set</b> 
    implements a set as a set of intervals - interval bounds are merged if 
    inserted intervals overlap or adjoin.

    Template parameter <b>DomainT</b>: The set's domain-type. Type of the 
    set's elements.

    Suitable as domain types are all datatypes that posess a partial order.
    In particular all discrete atomic datatypes like <tt>int, short, long</tt> and
    atomic pseudo-continuous datatypes <tt>float, double</tt> may be instantiated.
    
      Template parameter <b>IntervT=interval<DomainT></b>: Type of interval used
    to implement the set. The default <b>interval<DomainT></b> uses the
    interval class that comes with this library. Own implementation of interval
    classes are possible (but not trivial).

    <b>interval_set</b> implements a set <tt>SetT<DomainT></tt> as a set of intervals
    <tt>SetT<interval<DomainT>></tt>. Intervals will be merged on insertion, if they
    border each other or overlap.
  
    interval_base_set<DomainT> can thus be used like a set. As it is known from mathematics
    the union over a set of intervls is a set itself.

    <b>Class <tt>interval_set</tt> yields the following benefits: </b>
  
    <ul>
        <li> 
            A set of intervals is conceived as a set. The complexity involved with
            operations on intervals and sets of intervals is encapsulated.
            The user of the class who
            wants to perform set operations on sets of intervals is no more concerned
            with questions of overlapping, joining and bordering intervals.
        <li>
            <b>interval_set</b> gives an efficient implementation of sets consisting
            of larger contiguous chunks. Very large, even uncountably infinite sets of
            elements can be represented in a compact way and handled efficiently.
    </ul>

    Intervals in <b>interval_sets</b> are always unified, if intervals are adjoint. So the number
    of interval in an <b>interval_set</b> is always minimal. So informations about bounds
    of inserted intervals are lost if those intervals are adjoint to or overlapping
    with intervals within the <b>interval_set</b>.

    <b>Restrictions: </b>
    
    A small number of functions can only be used for <b>discrete</b> domain datatypes 
    (<tt>short, int, Date</tt> etc.) that implement operators <tt>++</tt> and <tt>--</tt>.
    These functions are tagged in the documentation.

    @author Joachim Faulhaber
*/

/*  JODO Using such functions
    for continuous domain datatypes yields compiletime errors. E.g. getting
    the <tt>first()</tt> element of a left open interval makes sense for intervals of
    int but not for intervals of double.
*/

template 
<
    typename             DomainT, 
    template<class>class Interval = itl::interval,
    template<class>class Compare  = std::less,
    template<class>class Alloc    = std::allocator
> 
class interval_set:    public interval_base_set<DomainT,Interval,Compare,Alloc>
{
public:
    // inherit all typedefs

    typedef interval_base_set<DomainT,Interval,Compare,Alloc> base_type;

    //PORT: The following types should be intereted from the base class
    // which does work with mscv++ but gcc complaines
    typedef Interval<DomainT> interval_type;
    typedef typename base_type::iterator iterator;
    typedef typename itl::set<interval_type,exclusive_less,Alloc> ImplSetT;

    // B: Constructors, destructors, assignment
    /// Default constructor for the empty set 
    interval_set(): base_type() {}
    /// Copy constructor
    interval_set(const interval_set& src): base_type(src) {}
    /// Constructor for a single interval
    explicit interval_set(const interval_type& itv): base_type() { insert(itv); }

    /// Virtual constructor
    virtual base_type* cons()const 
    { return new interval_set<DomainT,Interval,Compare,Alloc>(); }

    /// Does the set contain the interval  <tt>x</tt>?
    virtual bool contains(const interval_type& x)const;

    /// Insertion of an interval <tt>x</tt>
    virtual void insert(const interval_type&);
    void rec_insert(const interval_type&);

    /// Subtraction of an interval <tt>x</tt>
    virtual void subtract(const interval_type& x);
    void rec_subtract(const interval_type& x);

    /// Treatment of adjoint intervals on insertion
    virtual void handle_neighbours(const iterator& it);

private:
    iterator joint_insert(const iterator& left_it, const iterator& right_it);
} ;


template <typename DomainT, template<class>class Interval, template<class>class Compare, template<class>class Alloc>
bool interval_set<DomainT,Interval,Compare,Alloc>::contains(const interval_type& x)const
{ 
    // Emptiness is contained in everything
    if(x.empty()) 
        return true;
    else if (this->empty())
        return false;
    else if(x.last() < this->first())
        return false;
    else if(this->last() < x.first())
        return false;
    {
        typename ImplSetT::const_iterator it = this->_set.find(x);
        if(it == this->_set.end())
            return false;
        else
            return x.contained_in(*it);
    }
}


template <typename DomainT, template<class>class Interval, template<class>class Compare, template<class>class Alloc>
void interval_set<DomainT,Interval,Compare,Alloc>::rec_insert(const interval_type& x)
{
    if(x.empty()) return;

    std::pair<typename ImplSetT::iterator,bool> insertion = this->_set.insert(x);

    if(insertion.WAS_SUCCESSFUL)
        handle_neighbours(insertion.ITERATOR);
    else
    {
        typename ImplSetT::iterator found_it = insertion.ITERATOR;
        interval_type found = *found_it;
        DEV_ASSERT(!x.isDisjointTo(found));

        if(x.isSubsetOf(found)) return;
        else
        {
            this->_set.erase(found_it);
            interval_type extended = x;
            extended.extend(found);
            insert(extended);
        }
    }
}


template <typename DomainT, template<class>class Interval, template<class>class Compare, template<class>class Alloc>
void interval_set<DomainT,Interval,Compare,Alloc>::insert(const interval_type& x)
{
#ifdef _DEV_TEST
    interval_set<DomainT,interval_type> clone(*this);
#endif

    base_type::insert(x);

    ON_DEV_TEST(clone.rec_insert(x);)
    DEV_ASSERT(isEqual(clone));
}


template <typename DomainT, template<class>class Interval, template<class>class Compare, template<class>class Alloc>
void interval_set<DomainT,Interval,Compare,Alloc>::rec_subtract(const interval_type& x)
{
    if(x.empty()) return;
    typename ImplSetT::iterator found_it = this->_set.find(x);
    if(found_it==this->_set.end()) return;

    interval_type found = *found_it;
    interval_type inter; x.intersect(inter,found);

    // compute left and right residuals
    interval_type leftResid; found.leftSurplus(leftResid, inter);
    interval_type rightResid; found.rightSurplus(rightResid, inter);

    this->_set.erase(found_it);

    insert(leftResid);
    insert(rightResid);

    subtract(x);
}


template <typename DomainT, template<class>class Interval, template<class>class Compare, template<class>class Alloc>
void interval_set<DomainT,Interval,Compare,Alloc>::subtract(const interval_type& x)
{
    base_type::subtract(x);
}


template <typename DomainT, template<class>class Interval, template<class>class Compare, template<class>class Alloc>
void interval_set<DomainT,Interval,Compare,Alloc>::handle_neighbours(const iterator& it)
{
    DEV_ASSERT(this->_set.contains(*it));
    interval_type x = *it;

    if(it == this->_set.begin())
    {
        typename ImplSetT::iterator it_nxt=it; it_nxt++;
        if(it_nxt!=this->_set.end() && (*it).touches(*it_nxt)) 
            joint_insert(it, it_nxt);
    }
    else
    {
        // there is a predecessor
        iterator it_pred = it; it_pred-- ;

        if((*it_pred).touches(*it)) 
        {
            iterator it_extended = joint_insert(it_pred, it);

            iterator it_succ=it_extended; it_succ++;
            if(it_succ!=this->_set.end())
            {
                // it's a non border element that might have two touching neighbours
                if((*it_extended).touches(*it_succ)) 
                    joint_insert(it_extended, it_succ);
            }
        }
        else
        {
            iterator it_succ=it; it_succ++;
            if(it_succ!=this->_set.end())
            {
                // it's a non border element that might have a right touching neighbours
                if((*it).touches(*it_succ)) 
                    joint_insert(it, it_succ);
            }
        }
    }
}



template <typename DomainT, template<class>class Interval, template<class>class Compare, template<class>class Alloc>
typename interval_set<DomainT,Interval,Compare,Alloc>::iterator 
    interval_set<DomainT,Interval,Compare,Alloc>
    ::joint_insert(const iterator& left_it, const iterator& right_it)
{
    // both left and right are in the set and they are neighbours
    DEV_ASSERT((*left_it).excl_less(*right_it));
    DEV_ASSERT((*left_it).touches(*right_it));

    interval_type curItv = (*left_it);
    curItv.extend(*right_it);

    this->_set.erase(left_it);
    this->_set.erase(right_it);
    
    typename ImplSetT::iterator new_it = this->_set.insert(curItv).ITERATOR;
    J_ASSERT(new_it!=this->_set.end());
    return new_it;
}


    template <typename DomainT, template<class>class Interval, template<class>class Compare, template<class>class Alloc>
    inline bool is_element_equal(const interval_set<DomainT,Interval,Compare,Alloc>& lhs,
                                 const interval_set<DomainT,Interval,Compare,Alloc>& rhs)
    {
        return std::equal(lhs.begin(), lhs.end(), rhs.begin());
    }

    template <class Type>
    class type<itl::interval_set<Type> >
    {
    public:
        static std::string to_string()
        { return "interval_set<"+ type<Type>::to_string() +">"; }
    };



} // namespace itl

#endif


