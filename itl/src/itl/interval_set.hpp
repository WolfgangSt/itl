/*----------------------------------------------------------------------------+
Copyright (c) 2007-2008: Joachim Faulhaber
+-----------------------------------------------------------------------------+
Copyright (c) 1999-2006: Cortex Software GmbH, Kantstrasse 57, Berlin
+-----------------------------------------------------------------------------+
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
+----------------------------------------------------------------------------*/
/* ------------------------------------------------------------------
class interval_set
--------------------------------------------------------------------*/
#ifndef __interval_set_h_JOFA_990223__
#define __interval_set_h_JOFA_990223__

#include <itl/interval_base_set.hpp>
#include <itl/interval_set_joiner.hpp>
#include <itl/j_assert.hpp>

namespace itl
{

/// Implements a set as a set of intervals - merging adjoining intervals
/**    
    Template-class <b>interval_set</b> 
    implements a set as a set of intervals - interval bounds are merged if 
    inserted intervals overlap or adjoin.

    Template parameter <b>DomainT</b>: The set's domain-type. Type of the 
    set's elements.

    Suitable as domain types are all datatypes that posess a partial order.
    In particular all discrete atomic datatypes like <tt>int, short, long</tt> and
    atomic pseudo-continuous datatypes <tt>float, double</tt> may be instantiated.
    
      Template parameter <b>Interval=itl::interval</b>: Type of interval used
    to implement the set. The default <b>itl::interval</b> uses the
    interval class that comes with this library. Own implementation of interval
    classes are possible (but not trivial).

    <b>interval_set</b> implements a set <tt>set<DomainT></tt> as a set of intervals
    <tt>set<interval<DomainT>></tt>. Intervals will be merged on insertion, if they
    border each other or overlap.
  
    interval_base_set<DomainT> can thus be used like a set. As it is known from mathematics
    the union over a set of intervls is a set itself.

    <b>Class <tt>interval_set</tt> yields the following benefits: </b>
  
    <ul>
        <li> 
            A set of intervals is conceived as a set. The complexity involved with
            operations on intervals and sets of intervals is encapsulated.
            The user of the class who
            wants to perform set operations on sets of intervals is no more concerned
            with questions of overlapping, joining and bordering intervals.
        <li>
            <b>interval_set</b> gives an efficient implementation of sets consisting
            of larger contiguous chunks. Very large, even uncountably infinite sets of
            elements can be represented in a compact way and handled efficiently.
    </ul>

    Intervals in <b>interval_sets</b> are always unified, if intervals are adjoint. So the number
    of interval in an <b>interval_set</b> is always minimal. So informations about bounds
    of inserted intervals are lost if those intervals are adjoint to or overlapping
    with intervals within the <b>interval_set</b>.

    <b>Restrictions: </b>
    
    A small number of functions can only be used for <b>discrete</b> domain datatypes 
    (<tt>short, int, Date</tt> etc.) that implement operators <tt>++</tt> and <tt>--</tt>.
    These functions are tagged in the documentation.

    @author Joachim Faulhaber
*/

/*  JODO Using such functions
    for continuous domain datatypes yields compiletime errors. E.g. getting
    the <tt>first()</tt> element of a left open interval makes sense for intervals of
    int but not for intervals of double.
*/

template 
<
    typename             DomainT, 
    template<class>class Interval = itl::interval,
    template<class>class Compare  = std::less,
    template<class>class Alloc    = std::allocator
> 
class interval_set: 
	public interval_base_set<itl::interval_set_joiner,DomainT,Interval,Compare,Alloc>
{
public:
    // inherit all typedefs

	typedef interval_base_set<itl::interval_set_joiner,DomainT,Interval,Compare,Alloc> base_type;

    //PORT: The following types should be intereted from the base class
    // which does work with mscv++ but gcc complaines
    typedef Interval<DomainT> interval_type;
    typedef typename itl::set<interval_type,exclusive_less,Alloc> ImplSetT;
    typedef typename ImplSetT::iterator iterator;

    // B: Constructors, destructors, assignment
    /// Default constructor for the empty set 
    interval_set(): base_type() {}
    /// Copy constructor
    interval_set(const interval_set& src): base_type(src) {}
    /// Constructor for a single interval
    explicit interval_set(const interval_type& itv): base_type() { insert(itv); }

} ;



template <typename DomainT, template<class>class Interval, template<class>class Compare, template<class>class Alloc>
inline bool is_element_equal(const interval_set<DomainT,Interval,Compare,Alloc>& lhs,
                             const interval_set<DomainT,Interval,Compare,Alloc>& rhs)
{
    return std::equal(lhs.begin(), lhs.end(), rhs.begin());
}

template <class Type>
class type<itl::interval_set<Type> >
{
public:
    static std::string to_string()
    { return "interval_set<"+ type<Type>::to_string() +">"; }
};

} // namespace itl

#endif


