/*----------------------------------------------------------------------------+
Copyright (c) 2007-2008: Joachim Faulhaber
+-----------------------------------------------------------------------------+
Copyright (c) 1999-2006: Cortex Software GmbH, Kantstrasse 57, Berlin
+-----------------------------------------------------------------------------+
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
+----------------------------------------------------------------------------*/
#ifndef __tuple_computer_JOFA_040614_H__
#define __tuple_computer_JOFA_040614_H__

#include <itl/itl_map.hpp>
#include <itl/var_tuple_order.hpp>
#include <itl/split_interval_map.hpp>

namespace itl
{

	template <int varCountV>
	class tuple_computer_interface
	{
	public:
		typedef var_tuple<varCountV> var_tuple_type;
		typedef var_tuple_order<var_tuple_type> tuple_order_type;
		typedef itl::set<var_tuple_type, var_tuple_order> tuple_set_type;

	public:
		virtual ~tuple_computer_interface(){};

		//JODO Ergänzung + Comments + Zerlegung
		virtual void domain(tuple_set_type&)const=0;

		/// Add keyset of *this computer to tupelset 'accu'
		virtual void addDomain(tuple_set_type& accu)const=0;

		/** Load Computer from src. If *this has a different TupelOrder
			*this is not a copy of 'src' but a recomputation according
			to the different TupelOrder */
		virtual void load(const tuple_computer_interface& src)=0;

		/** Align *this TupelsComputers for domain such that this->domain()==domain.
			Insert 0 or empty values for all tupels which are not in *this.	*/
		virtual void alignFor(const tuple_set_type& domain)=0;

		virtual std::string asString()const=0;
	};



	// Alternative Names
	// TupelCubeT
	// TupicCubeT
	// TupyCubeT
	// HyperCubeT
	// TupAss TupelAssociativeComputer
	// A Tupel based Value Accumulator TuBaVator
	// A Value associating Tupel Accumulator AVaTAr

	/// Base class template for tuple computers aggregating values associated to tuples
	/** On insertion of a (t1, ..., tn)->v tuple value pair, a value within
	    the tuple computer is summed by v, if the tuple t is already contained in
		the tuple_computer_base.

		Template parameter varCountV defines the size of the tuples.

		Template parameter CounterT is the value type of the tuple_computer_base.
		Those are the values to aggregated.
	*/
	template <int varCountV, class CounterT>
	class tuple_computer_base : public tuple_computer_interface<varCountV>
	{
	public:

	/** @name A: Type definitions for the template class 
	*/
	//@{ 
		typedef var_tuple<varCountV> var_tuple_type;
		typedef var_tuple_order<var_tuple_type> tuple_order_type;
		/// Container type for the implementation 
		typedef itl::map<var_tuple_type, CounterT, var_tuple_order> ImplMapTD;
		/// iterator
		typedef typename ImplMapTD::iterator iterator;
		/// const_iterator
		typedef typename ImplMapTD::const_iterator const_iterator;

		/// value type of the implementing container
		typedef typename ImplMapTD::value_type value_type;
		/// key type of the implementing container
		typedef typename ImplMapTD::key_type   key_type;
		/// data type of the implementing container
		typedef typename ImplMapTD::data_type  data_type;

		/// Type of strict weak ordering
		typedef typename ImplMapTD::key_compare key_compare;

		typedef CounterT CounterTD;
	//@}

		// B: Constructors, destructors, assignment
		/// Default constructor for the empty map 
		tuple_computer_base(): m_map() {}
		/// Copy constructor
		tuple_computer_base(const tuple_computer_base& src): m_map(src.m_map) {}

		/// Construct from order
		tuple_computer_base(const key_compare& ord): m_map(ord) {}

		// Virtual constructor
		//JODO? virtual tuple_computer_base* cons()const=0;
		/// Virtual destructor
		virtual ~tuple_computer_base(){};


		/// Assignment operator
		tuple_computer_base& operator = (const tuple_computer_base& src) 
		{
			m_map.ImplMapTD::operator=(src.m_map);
			return *this;  
		}

		// ------------------------------------------------------------------------
		// Interface MapIT
		// C:
		
		/// Remove all elements from the map
		void clear() { m_map.clear(); }
		/// Is the map empty?
		bool empty()const { return m_map.empty(); }
		/// Does the map contain an element for key x
		bool contains(const var_tuple_type& x)const { return m_map.contains(x); }
		/// Does the map contain a valuepair (tupel, counter)
		bool contains(const value_type& x)const;

		/// Get the set of keys
		void domain(tuple_set_type& domain)const;
		/// 
		void addDomain(tuple_set_type& domain)const;


	/** @name F: Tester
	*/
	//@{
		/// <tt>*this</tt> is subset of <tt>super</tt>
		bool isSubsetOf(const tuple_computer_base& super)const;
		/// <tt>*this</tt> is subset of <tt>super</tt>
		bool operator <= (const tuple_computer_base& super)const;

		/// Equality
		bool isEqual(const tuple_computer_base& x2)const
		{ return isSubsetOf(x2) && x2.isSubsetOf(*this); }
		/// Equality operator
		bool operator == (const tuple_computer_base& x2)const { return isEqual(x2); }
		/// Inequality operator
		bool operator != (const tuple_computer_base& x2)const { return !isEqual(x2); }

	//@}


	/** @name G: Modificators
	*/
	//@{ 
		/** Insertion of a (tupel, content) pair <tt>(t,x)</tt> */		
		void insert(const var_tuple_type& t, CounterT x) 
		{ insert( value_type(t, x) ); }

		/** Insertion of a (tupel, content) pair as <tt>value_pair</tt> */		
		void insert(const value_type& vt); 
	//@}

	/** @name H: value search
	*/
	//@{
		/** */
		iterator find(const var_tuple_type& tupel) { return m_map.find(tupel); }
		const_iterator find(const var_tuple_type& tupel)const { return m_map.find(tupel); }
		//@}



	/** @name I: Interval iterators
	*/
	//@{
		///
		iterator begin() { return m_map.begin(); }
		///
		iterator end()   { return m_map.end(); }
		///
		const_iterator begin()const { return m_map.begin(); }
		///
		const_iterator end()const   { return m_map.end(); }
	//@}

	/** @name S: String representation
	*/
	//@{
		///
		std::string asString()const { return m_map.asString(); }
	//@}


	int size()const { return m_map.size(); }

	// NOTE! Die Ordnung, die ein TupelComputer verwendet ist fest, wir können zwar eine
	// Kopie dieses Ordnungs-Objektes bekommen, aber keine Referenz. Also sind alle
	// möglichen Transformationen nur dadurch zu machen, dass wir einen neuen
	// Tupelcomputer mit entsprechendem Ordnungsobjekt (Funktor) kreieren und es
	// dann befüllen. Der OrdnungsFunktor muss alle Möglichkeiten zur Verfügung
	// stellen, also Umsortierung (Permutation), Projektion und Gruppierung.
	// Gruppierung beinhaltet auch bedingte Äquivalenz. Dazu brauchen wir noch
	// Filter: Ausblenden von Wertemengen und bedingte Filter: Ausblenden von Werten
	// in Abhängigkeit von den Werten anderer UVs (oder UV-Gruppierungen)

	private:
		ImplMapTD m_map;
	};


	template <int varCountV, class CounterT>
	void tuple_computer_base<varCountV, CounterT>::domain(tuple_set_type& domain)const
	{
		domain.clear();
		addDomain(domain);
	}


	template <int varCountV, class CounterT>
	void tuple_computer_base<varCountV, CounterT>::addDomain(tuple_set_type& domain)const
	{
		const_FORALL_THIS(tupel_)
			domain.insert((*tupel_).KEY_VALUE);
	}


	template <int varCountV, class CounterT>
	void tuple_computer_base<varCountV, CounterT>::insert(const value_type& val)
	{
		pair<ImplMapTD::iterator,bool> insertion = m_map.insert(val);

		if(!insertion.WAS_SUCCESSFUL)
			(*insertion.ITERATOR).CONT_VALUE += val.CONT_VALUE;
	}


	// ------------------------------------------------------------------------
	// JODO THINK: Es ist fraglich, ob wir überhaupt abgeleitete TupelComputer
	// brauchen. Vielleicht lässt sich ja alles über entsprechende CounterT-
	// Instanzen regeln.
	// ------------------------------------------------------------------------

	/// Aggregates values (amounts) associated to tuples. 
	/** amount_tuple_computer is a TupleComputer that aggregates amounts
	    associated to tuples.

		Template parameter varCountV defines the size of the used tuples.

		CounteeTV is the amount type, the type that is aggrgated.
		Usually this shall be a numeric type. Yet it can also be
		intantiated with any +=summable class type.
	*/
	template <int varCountV, class CounteeTV>
		class amount_tuple_computer : public tuple_computer_base<varCountV, CounteeTV>
	{
	public:
		typedef tuple_computer_base<varCountV, CounteeTV> BaseTD;
		typedef typename BaseTD::key_type var_tuple_type;
		typedef typename BaseTD::key_type key_type;

	public:
		// Default Ctor
		amount_tuple_computer(): BaseTD() {}
		// Copy Ctor
		amount_tuple_computer(const amount_tuple_computer& src): BaseTD(src) {}
		// Ctor from strict weak ordering
		amount_tuple_computer(const key_compare& order): BaseTD(order) {}

	public:
		// Special interface that can not be expressed by TupelComputerT

		void load(const tuple_computer_interface<varCountV>& srcI);

		void alignFor(const tuple_set_type& domain)
		{
			const_FORALL(tuple_set_type, it_, domain)
				insert(*it_, CounteeTV());
		}

	};

	template <int varCountV, class CounterT>
	void amount_tuple_computer<varCountV, CounterT>::load(const tuple_computer_interface<varCountV>& srcI)
	{
		const amount_tuple_computer& src = dynamic_cast<const amount_tuple_computer&>(srcI);
		const_FORALL(amount_tuple_computer, it_, src)
			insert(*it_);
	}



	// ------------------------------------------------------------------------
	/** class date_tuple_computer: Merkmalskombinationsrechner (flavor: Zeitpunktrechner) 

		Jedem Tupel (Merkmalskombination) wird ein Map assoziiert, das Zeitpunkte
		(Dates) zählen kann. 
	*/
	template <int varCountV, class TimeTV, class CounteeTV>
		class date_tuple_computer : public tuple_computer_base<varCountV, itl::map<TimeTV, CounteeTV> >
	{
	public:
		typedef itl::set<var_tuple_type, var_tuple_order> tuple_set_type;
		typedef itl::map<TimeTV, CounteeTV> CounterTD;
		typedef tuple_computer_base<varCountV, CounterTD> BaseTD;
		typedef typename BaseTD::key_type var_tuple_type;

	public:
		// Default Ctor
		date_tuple_computer(): BaseTD() {}
		// Copy Ctor
		date_tuple_computer(const date_tuple_computer& src): BaseTD(src) {}
		// Ctor from strict weak ordering
		date_tuple_computer(const key_compare& order): BaseTD(order) {}

	public:
		// Special interface that can not be expressed by TupelComputerT
		
		void load(const tuple_computer_interface<varCountV>& srcI);

		void alignFor(const tuple_set_type& domain)
		{
			const_FORALL(tuple_set_type, it_, domain)
				insert(*it_, CounterTD());
		}

	};

	template <int varCountV, class TimeTV, class CounteeTV>
	void date_tuple_computer<varCountV,TimeTV,CounteeTV>::load(const tuple_computer_interface<varCountV>& srcI)
	{
		const date_tuple_computer& src = dynamic_cast<const date_tuple_computer&>(srcI);
		const_FORALL(date_tuple_computer, it_, src)
			insert(*it_);
	}



	// ------------------------------------------------------------------------
	/** class interval_tuple_computer: Merkmalskombinationsrechner (flavor: Zeitraumrechner) 
		Jedem Tupel (Merkmalskombination) wird ein SlitItvMap assoziiert, das 
		Zeiträume (Itv=Interval) zählen kann. Genauer gesagt werden Zustände
		gezählt, die für einen Zeitraum anhalten. Bei Überlappungen der Zeiträume
		müssen die die Häufigkeiten im SplitItvMap entsprechend aufaddiert werden.
	*/
	template <int varCountV, class TimeTV, class CounteeTV>
		class interval_tuple_computer : public tuple_computer_base<varCountV, split_interval_map<TimeTV, CounteeTV> >
	{
	public:
		typedef itl::set<var_tuple_type, var_tuple_order> tuple_set_type;
		typedef split_interval_map<TimeTV, CounteeTV> CounterTD;
		typedef tuple_computer_base<varCountV, split_interval_map<TimeTV, CounteeTV> > BaseTD;
		typedef typename BaseTD::key_type var_tuple_type;
		typedef typename BaseTD::CounterTD::IntervalTD IntervalTD;

	private:
		typedef itl::map<TimeTV, CounteeTV> DateMapTD;

	public:
		// Default Ctor
		interval_tuple_computer(): BaseTD() {}
		// Copy Ctor
		interval_tuple_computer(const interval_tuple_computer& src): BaseTD(src) {}
		// Ctor from strict weak ordering
		interval_tuple_computer(const key_compare& order): BaseTD(order) {}

	public:
		// Special interface that can not be expressed by TupelComputerT

		void load(const tuple_computer_interface<varCountV>& srcI);

		// Eine Menge von ZeitPUNKTEN einfügen. Diese werden in Intervalle gewandelt
		void insertDateMap(const var_tuple_type tup, const DateMapTD& date);

		void alignFor(const tuple_set_type& domain)
		{
			const_FORALL(tuple_set_type, it_, domain)
				insert(*it_, CounterTD());
		}
	};


	template <int varCountV, class TimeTV, class CounteeTV>
	void interval_tuple_computer<varCountV,TimeTV,CounteeTV>::load(const tuple_computer_interface<varCountV>& srcI)
	{
		const interval_tuple_computer& src = dynamic_cast<const interval_tuple_computer&>(srcI);
		const_FORALL(interval_tuple_computer, it_, src)
			insert(*it_);
	}

	template <int varCountV, class TimeTV, class CounteeTV>
	void interval_tuple_computer<varCountV,TimeTV,CounteeTV>::insertDateMap(const var_tuple_type tup, const DateMapTD& date)
	{
		CounterTD itvCounter;
		const_FORALL(DateMapTD, date_, date)
		{
			itvCounter.insert(
				CounterTD::value_type(
					CounterTD::IntervalTD((*date_).KEY_VALUE, (*date_).KEY_VALUE), 
					(*date_).CONT_VALUE
					)
				);
		}

		insert(value_type(tup, itvCounter));
	}



	//JODO: Where to put this kind of functionality
	template <class ItvDomTV, class CodomTV>
	void intervalize(interval_base_map<ItvDomTV, CodomTV>& itvMap, const itl::map<ItvDomTV, CodomTV>& dateMap)
	{
		typedef itl::map<ItvDomTV, CodomTV> DateMapTD;
		typedef interval_base_map<ItvDomTV, CodomTV> ItvMapTD;

		itvMap.clear();
		const_FORALL(DateMapTD, date_, dateMap)
		{
			itvMap.insert(
				ItvMapTD::value_type(
					ItvMapTD::IntervalTD((*date_).KEY_VALUE, (*date_).KEY_VALUE), 
					(*date_).CONT_VALUE
					)
				);
		}
	}

	//JODO Move this; 
	//JODO DESIGN: Memfunction of interval_base_set? destructive + constructive. Self-deviding

	//NOTE: ItvMap GridSum
	template <class ItvDomTV, class CodomTV>
	void sumWithin(interval_base_map<ItvDomTV, CodomTV>& gridSums, 
				   interval_base_map<ItvDomTV, CodomTV>& interSection, 
				   const interval_base_map<ItvDomTV, CodomTV>& itvMap, 
				   const split_interval_set<ItvDomTV>& grid)
	{
		typedef interval_base_map<ItvDomTV, CodomTV> ItvMapTD;
		typedef split_interval_set<ItvDomTV> DiscItvSetTD;

		gridSums.clear();
		interSection.clear();
		if(itvMap.empty()) return;

		ItvMapTD* aux = itvMap.cons();
		//JODO OPTI: optimize using the ordering: if intervalls are beyond borders we can terminate
		const_FORALL(DiscItvSetTD, itv_, grid)
		{
			itvMap.intersect(*aux, *itv_);
			gridSums.insert(ItvMapTD::value_type(*itv_, (*aux).volume()));
			interSection += (*aux);
		}
		
	}

}

#endif // __tuple_computer_JOFA_040614_H__



