/*----------------------------------------------------------------------------+
Copyright (c) 2007: Joachim Faulhaber
+-----------------------------------------------------------------------------+
Boost Software License - Version 1.0 - August 17th, 2003

Permission is hereby granted, free of charge, to any person or organization
obtaining a copy of the software and accompanying documentation covered by
this license (the "Software") to use, reproduce, display, distribute,
execute, and transmit the Software, and to prepare derivative works of the
Software, and to permit third-parties to whom the Software is furnished to
do so, all subject to the following:

The copyright notices in the Software and this entire statement, including
the above license grant, this restriction and the following disclaimer,
must be included in all copies of the Software, in whole or in part, and
all derivative works of the Software, unless such copies or derivative
works are solely in the form of machine-executable object code generated by
a source language processor.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
DEALINGS IN THE SOFTWARE.
+----------------------------------------------------------------------------*/
#ifndef __itl_Law_h_JOFA_070411__
#define __itl_Law_h_JOFA_070411__

#include <string>
#include <set>
#include <lokixt/Tuple.h>

namespace itl
{

    /** abstract template class Law:
        A Law can hold for a given set of variables.
        A Law together with the set of input variables is an instance of the law.
        The evaluation of the law results in a set of output variables.
        Output variables hold interim and final results of the evaluation of the law.
    */
    template <typename InputTypes, typename OutputTypes>
    class Law
    {
    public:
        typedef InputTypes               input_types;
        typedef OutputTypes              output_types;
        typedef typename Loki::tuple<InputTypes>  input_tuple;
        typedef typename Loki::tuple<OutputTypes> output_tuple;
    public:
        virtual ~Law(){}
        virtual bool holds()=0;
        virtual bool debug_holds()=0;

        virtual void setInstance(const input_tuple&)=0;
        virtual void getInstance(input_tuple&, output_tuple&)const=0;
        virtual void getInputInstance(input_tuple&)const=0;
        virtual void getOutputInstance(output_tuple&)const=0;

        virtual bool operator == (const Law& rhs)const=0;
        virtual bool operator < (const Law& rhs)const=0;
        virtual size_t size()const=0;

        virtual std::string name()const=0;
        virtual std::string formula()const=0;
        virtual std::string typeString()const=0;
    };


    template <typename InputTypes, typename OutputTypes>
    class LawBase : public Law<InputTypes, OutputTypes>
    {
    public:
        typedef Law<InputTypes, OutputTypes>     base_type;
        typedef typename base_type::input_tuple  input_tuple;
        typedef typename base_type::output_tuple output_tuple;

    public:
        virtual size_t size()const=0;
        virtual bool holds()=0;

        bool debug_holds(){ return holds(); }

        void setInstance(const input_tuple& inVars)
        { _inputTuple = inVars; }

        void getInstance(input_tuple& inVars, output_tuple& outVars)const
        { inVars = _inputTuple; outVars = _outputTuple; }

        void getInputInstance(input_tuple& inVars)const
        { inVars = _inputTuple; }

        void getOutputInstance(output_tuple& outVars)const
        { outVars = _outputTuple; }

        bool operator == (const base_type& rhs)const
        {
            return size() == rhs.size(); //JODO
        }

        bool operator < (const base_type& rhs)const
        {
            return size() < rhs.size();
        }


        std::string name()const { return "unspecified law"; }
        std::string formula()const { return "unspecified formula"; }
        std::string typeString()const { return ""; }


        template<unsigned int index>
        typename Loki::TL::TypeAt<InputTypes, index>::Result 
            setInputValue(const typename Loki::TL::TypeAt<InputTypes, index>::Result& value) 
        { return Loki::tup::refer<index>(_inputTuple)=value; }

        template<unsigned int index>
        typename Loki::TL::TypeAt<InputTypes, index>::Result getInputValue()const 
        { return Loki::tup::get<index>(_inputTuple); }

        template<unsigned int index>
        typename Loki::TL::TypeAt<OutputTypes, index>::Result 
            setOutputValue(const typename Loki::TL::TypeAt<OutputTypes, index>::Result& value) 
        { return Loki::tup::refer<index>(_outputTuple)=value; }

        template<unsigned int index>
        typename Loki::TL::TypeAt<OutputTypes, index>::Result getOutputValue()const 
        { return Loki::tup::get<index>(_outputTuple); }

    private:
        input_tuple  _inputTuple;
        output_tuple _outputTuple;
    }; //class LawBase

    enum InputVarIndex  { operand_a, operand_b, operand_c, operand_d, operand_e };
    enum OutputVarIndex { lhs_result, rhs_result };

} // namespace itl

#endif //__itl_Law_h_JOFA_070411__

